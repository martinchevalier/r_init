--- 
title: "Formation R Initiation"
author: "Martin Chevalier"
date: "`r Sys.Date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
---

```{r setup, include=FALSE}
.download <- FALSE
.sol <- FALSE
knitr::opts_chunk$set(comment = "  ##", collapse = TRUE, fig.path = "../figures/")
options(scipen = 10, stringsAsFactors = TRUE, repos = "https://cran.rstudio.com/")

# Récupération des données 
if(.download){
  file <- tempfile()
  download.file("http://r.slmc.fr/donnees.zip", file)
}else file <- "_output/donnees.zip"
.dir <- tempdir()
unzip(file, exdir = .dir)
knitr::opts_knit$set(root.dir = .dir)

# Chargement des packages (après installation éventuelle)
lapply(c("foreign", "haven", "data.table", "descr", "moments", "Hmisc", "pryr", "microbenchmark"), function(pkg) {
  if (system.file(package = pkg) == "") install.packages(pkg)
  library(pkg, character.only = TRUE)
})


### Sections ----

set.seed(1)
.numHide <- 0
.numQuestion <- 0
.html <<- knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"
.pdf <<- knitr::opts_knit$get("rmarkdown.pandoc.to") == "latex"

.module <- function(numModule, text){
  .numModule <<- numModule
  if(.html) cat("#", text, sep = "")
  if(.pdf){
    if(.numModule > 1) cat("\\addtocontents{cp}{\\vspace{\\normalbaselineskip}}")
    cat("\\chapter{", text, "}", sep = "")
    cat("\n \\minitoc \n")
  }
}

.partie <- function(text){
  if(.html) cat("##", text, sep = "")
  if(.pdf) cat("##", text, "", sep = "")
}

.souspartie <- function(text){
  if(.html) cat("###", text, sep = "")
  if(.pdf) cat("###", text, sep = "")
}

### Fonctions outils ----

# Arrondis
.f <- function(x, digits = 2){
  formatC(as.numeric(x), format = "f", decimal.mark = ",",  big.mark = " ", digits = digits)
}

# Index de fonctions
.fun <- function(fun, bold = FALSE){
  if(.pdf) r <- paste0("\\index{\\texttt{", fun, "}", if(bold) "|textbf" else "",  "}")
  if(.html) r <- ""
  return(r)
}

# Fonction pour garantir la cohérence des références internes
# entre la version web et la version imprimée
.ref <- function(text, link_html = NULL, link_pdf = NULL){
  if(.html & !is.null(link_html)) out <- paste0("[", text, "](", link_html, ")")
  if(.html & is.null(link_html)) out <- paste0(text)
  if(.pdf & !is.null(link_pdf)) out <- paste0("[\\underline{", text, "}](", link_pdf, ")")
  if(.pdf & is.null(link_pdf)) out <- paste0("\\underline{", text, "}")
  return(out)
}


# Introduction d'un cas pratique
.question <- function(text = NULL){
  .numQuestion <<- .numQuestion + 1
  cat("\n"); cat("\\ \n"); cat("\n");
  cat("#### **Cas pratique ", .numModule, ".", .numQuestion, "** ", text, sep = "")
  if(.pdf) cat(
    "\n \\addcontentsline{cp}{caspratique}{"
    , .numModule, ".", .numQuestion, " ", text
    , "}", sep = ""
  )
  
}

# Solution d'une question
.beginsol <- function(){
  .numHide <<- .numHide + 1
  if(.html){
    cat("<div style = \"text-align: right;\">")
    cat("<button type=\"button\" onclick=\"hide('sol", .numHide, "')\">Afficher/masquer la solution</button>", sep = "")
    cat("</div>")
    cat("<div id='sol", .numHide, "' style=\"display: none; height: 0;\">\n<hr/>", sep = "")
  }
  if(.pdf) cat("\\ifsol \n \\begin{center} \\rule{0.5\\linewidth}{\\linethickness}\\end{center} \n")
}
.endsol <- function(){
  if(.html) cat("\n<hr /></div>\n\n \\ \n \n")
  if(.pdf) cat("  \n  \\begin{center} \\rule{0.5\\linewidth}{\\linethickness}\\end{center} \n \\bigskip \n \\fi \n")
}

# Indication d'une question
.indic <- function(text){
  .numHide <<- .numHide + 1
  if(.html){
    cat("<div style = \"text-align: right;\">")
    cat("<button type=\"button\" onclick=\"hide('sol", .numHide, "');this.style.display='none'\">Indication</button>", sep = "")
    cat("</div>")
    cat("<div id='sol", .numHide, "' style=\"display: none; height: 0;\">\n", sep = "")
    cat(text)
    cat("\n</div>\n\n \\ \n \n")
  }
  if(.pdf){
    cat("\\ifsol \n")
    cat(text)
    cat("\\fi \n")
  }
}

```

# Introduction {-}

Cette page rassemble les supports de la formation R initiation des 22 et 23 janvier 2018 :

- [Module 1 Prise en main du logiciel (.html)](module1.html)

- [Module 2 Manipuler les outils fondamentaux du langage (.html)](module2.html)

- [Module 3 Travailler avec des données statistiques (.html)](module3.html)

- [Données utilisées pour les cas pratiques (.zip, 3,6 Mo)](donnees.zip)

- [Support de formation en format imprimable (.pdf)](livret.pdf)

- [Support de formation en format imprimable et avec solutions (.pdf)](livret_sol.pdf)

- [Support de présentation utilisé lors de la formation (.pdf)](presentation.pdf)


**Note** Les pages html peuvent être téléchargées sous forme de fichiers .html autonomes et consultées hors connexion.

\ 

Les supports de cette formation ont été conçus sous RStudio avec [R Markdown](http://rmarkdown.rstudio.com/) et compilés le `r format(Sys.Date(), format="%d/%m/%Y")`. Certains éléments de mise en forme du site compagnon sont repris de l'ouvrage [R packages](http://r-pkgs.had.co.nz/) de Hadley Wickham. 
  
Ces supports seront durablement disponibles à l'adresse [http://   r.slmc.fr](http://r.slmc.fr/) et leur code source sur [github](https://github.com/martinchevalier/r_insee). L'ensemble est librement réutilisable sous &copy;\ 2016-2018 Martin Chevalier [CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/fr).

\ 

[Retour à la page d'accueil](..)

<!--chapter:end:index.Rmd-->

```{r, include = FALSE}
rm(list = ls())
if(!exists(".initOK")) source("init.R", encoding = "latin1")
.init()
```

```{r, results = "asis", echo = FALSE}
.module(numModule = 1, "Prise en main du logiciel")
```

```{r, results = "asis", echo = FALSE}
.partie("Un peu d'histoire et quelques grands principes")
```


R est un langage utilisé pour le traitement de données statistiques créé au début des années 1990 par deux chercheurs de l'université d'Auckland, Ross Ihaka and Robert Gentleman. Il reprend de très nombreux éléments du langage S créé par le statisticien américain John Chambers à la fin des années 1970 au sein des [laboratoires Bell](https://fr.wikipedia.org/wiki/Laboratoires_Bell).

La première version stable a été rendue publique en 2000 : d'abord principalement diffusé parmi les chercheurs et les statisticiens "académiques", R est aujourd'hui **de plus en plus utilisé au sein des Instituts nationaux de statistiques**.


```{r, results = "asis", echo = FALSE}
.souspartie("R : un logiciel libre")
```


À la différence d'autres logiciels de traitement statistique (SAS, SPSS ou Stata notamment), R est un **logiciel libre** : sa licence d'utilisation est gratuite et autorise chaque utilisateur à **accéder, modifier ou redistribuer son [code source](https://github.com/wch/r-source)**. En pratique, il est maintenu par une équipe (la *[R Core Team](https://www.r-project.org/contributors.html)*) qui veille à la stabilité du langage et de ses implémentations logicielles.

Une des conséquences de cette philosophie "libre" présente dès les premières années du développement du langage est le rôle qu'y jouent les **modules complémentaires**, ou ***packages***. Au-delà des "briques" fondamentales de la *R Core Team*, **plusieurs milliers de *packages* sont disponibles et librement téléchargeables** *via* le [*Comprehensive R Archive Network*](https://cran.r-project.org/) (ou CRAN) ou encore par le biais de plate-formes de développement collaboratif comme [GitHub](https://github.com/). Ces *packages*, dont l'installation est particulièrement simple dans R, enrichissent considérablement les fonctionnalités du logiciel et sont une de ses principales forces.

------------

**Remarque importante** Comme de nombreux logiciels libres, R est très influencé par le fonctionnement du système d'exploitation Linux. À ce titre, **certains éléments de sa syntaxe peuvent dérouter un utilisateur de Windows** :

- **R est sensible à la casse** : il distingue ainsi `matable` de `MATABLE` ou encore de `maTable`, même sous Windows (contrairement à SAS notamment) ;
- **dans R les chemins doivent utiliser des `/` et non des `\`** : ainsi, pour pointer vers le dossier `V:\enquete\donnees` il faut saisir dans R `V:/enquete/donnees`.

------------

\ 

De manière plus générale, le fonctionnement de R est **plus proche de celui d'un langage de programmation "classique"** (Python, C, Java, etc.) **que de celui des autres logiciels de traitements statistiques**. Une manière d'introduire cet aspect fondamental du logiciel est de développer la **célèbre citation de John Chambers**: 

> *To understand computations in R, two slogans are helpful:*
>
> - *Everything that exists is an object.*
>
> - *Everything that happens is a function call.*
>
> *John Chambers*


```{r, results = "asis", echo = FALSE}
.souspartie("\"Tout ce qui existe est un objet\"")
```

Tout ce qui existe et est manipulable dans R est un **objet** identifié par son nom et par son **environnement de référence**. Par défaut, tous les objets créés par l'utilisateur apparaissent dans l'environnement dit "global" (`.GlobalEnv`) qui est implicite, de façon analogue à la bibliothèque `WORK` de SAS.

Pour créer un objet, la méthode la plus simple consiste à assigner une valeur à un nom avec l'opérateur `<-``r .fun("<-", bold = TRUE)`. Par exemple :

```{r, collapse = TRUE}
a <- 4
```

assigne la valeur 4 à l'objet `a` (dans l'environnement global). Dès lors, il est possible d'afficher la valeur de `a` et de la **réutiliser dans des calculs** :

```{r, collapse = TRUE}
# Affichage de la valeur de a avec la fonction print() ...
print(a)

# ... ou tout simplement en tapant son nom
a

# Utilisation de a dans un calcul
2 * a

# Définition et utilisation de b
b <- 6
a * b
```

Il est bien sûr possible d'assigner à un nom **non pas une valeur numérique unique** (comme ici 4 à `a` et 6 à `b`) **mais des données provenant d'une table externe**. 

**Exemple** Le code suivant associe à l'objet `reg` les caractéristiques des régions dans le [Code officiel géographique](https://www.insee.fr/fr/information/2666684) (COG) au 1er janvier 2017.

`r .fun("read.delim")`
```{r}
# Lecture du fichier du COG contenant le nom des régions
# et stockage dans l'objet dont le nom est `reg`
reg <- read.delim("reg2017.txt")
```

```{r, eval=FALSE}
# Affichage de l'objet reg
reg
```
```{r, echo=FALSE}
reg[, -5]
```

\ 

Dans tous les cas, les objets créés sont **stockés dans la mémoire vive de l'ordinateur** (comme dans Stata), ce qui présente des avantages et des inconvénients :

- (+) on ne modifie jamais les fichiers originaux, uniquement les objets chargés en mémoire ;
- (+) les opérations sur les objets chargés peuvent être **extrêmement rapides**, car elles ne nécessitent pas de lire des données sur le disque ;
- (-) à chaque lancement de R il faut **recharger les données nécessaires en mémoire** ;
- (-) la **taille totale des données chargées ne peut pas excéder celle de la mémoire vive installée** (80 Go partagés sur un serveur AUS actuellement).


```{r, results = "asis", echo = FALSE}
.souspartie("\"Tout ce qui se produit est un appel de fonction\"")
```

Une fois les objets sur lesquels on souhaite travailler créés (*i.e.* les tables importées), R dispose d'un grand nombre de **fonctions** pour transformer ces données et mener à bien des traitements statistiques. **Dans R une fonction est un type d'objet particulier** : une fonction est identifiée par son nom (dans un environnement de référence) suivi de parenthèses.

**Exemple** La fonction `ls()``r .fun("ls")` (sans argument) permet d'afficher les objets chargés en mémoire.

```{r}
# Affichage des objets chargés en mémoire avec ls()
ls()
```

Il y a pour l'instant trois objets en mémoire : `a`, `b` et `reg`. 

**Progresser dans la maîtrise de R signifie essentiellement étendre son "vocabulaire" de fonctions connues**. Avec le temps, il est fréquent que l'on revienne sur d'anciens codes pour les simplifier en utilisant des fonctions découvertes entre temps (ou parfois en exploitant mieux les mêmes fonctions !).

\ 


**Il est également extrêmement facile et courant dans R de créer ses propres fonctions**.

**Exemple** La fonction `monCalcul()` renvoie le résultat de `param1 * 10 + param2`, où `param1` et `param2` sont deux nombres.`r .fun("function", bold = TRUE)`

```{r}
# Définition de la fonction monCalcul()
monCalcul <- function(param1, param2){
  resultat <- param1 * 10 + param2
  return(resultat)
}

# Test de la fonction monCalcul() avec les valeurs 1 et 3
monCalcul(1, 3)

# Test de la fonction monCalcul() avec les valeurs a et 2
a
monCalcul(a, 2)
```

Quand on saisit uniquement le **nom de la fonction (sans parenthèse)**, R affiche son code :
```{r}
# Affichage du code de la fonction monCalcul()
monCalcul
```

À noter que **rien ne distingue les fonctions pré-chargées dans le logiciel** (comme `read.delim()` ou `ls()` utilisées précédemment) **des fonctions créées par l'utilisateur**. Il est ainsi tout à fait possible d'afficher le code de ces fonctions.`r .fun("read.delim")`
```{r}
# Affichage du code de la fonction read.delim()
read.delim
```

C'est une **conséquence du caractère "libre" du logiciel** : non seulement le code des fonctions pré-chargées est consultable, mais il est également modifiable.

**Exemple** Il est tout à fait possible dans R (même si cela n'a *a priori* pas grand intérêt...) de modifier la signification des signes arithmétiques (qui comme toutes les autres opérations dans R correspondent à des fonctions).

```{r}
# On décide d'associer au signe + l'opération effectuée habituellement 
# par le signe - :
`+` <- `-`

# Le signe + est désormais associé à la soustraction :
2 + 2
```

Cet exemple illustre la **très grande souplesse de R comme langage** : tous ses aspects sont modifiables, si bien qu'il est possible de **développer facilement des programmes R parfaitement adaptés aux besoins les plus spécifiques**.

```{r, results = "asis", echo = FALSE}
.partie("Découverte de l'interface")
```

```{r, echo = FALSE}
rm(list=ls())
```

En tant que tel, R est un *langage* susceptible d'être implémenté dans de [nombreuses interfaces](https://fr.wikipedia.org/wiki/R_(langage)#Interfaces). Le choix est fait ici de présenter d'abord son **implémentation minimale** (en mode "console") puis une **implémentation beaucoup plus complète** par le biais du programme [RStudio](https://www.rstudio.com/). Dans tous les cas, la plate-forme utilisée est Windows.

```{r, results = "asis", echo = FALSE}
.souspartie("Effectuer des manipulations de base dans la console")
```

Par défaut sous Windows, R est fourni avec une interface graphique minimiale (`Rgui.exe`), dont la fenêtre principale est une **console**, c'est-à-dire un **terminal** dans lequel taper des instructions (comparable à l'invite de commandes Windows). Les instructions sont à taper après le signe `>` en rouge.

![Interface fenêtrée de R sous Windows](../figures/Interface_R.png)

Toutes les commandes peuvent être passées au logiciel par le biais de la console, même si **en pratique les commandes les plus longues sont stockées et soumises depuis un fichier de script** (*cf.* la sous-partie suivante). En particulier, il est fréquent d'effectuer dans la console:

- **des assignations et des rappels de valeur** : le signe `<-` permet d'assigner des valeurs à des noms pour être réutilisées ultérieurement. Quand une valeur est assignée à un nom, il suffit de taper le nom dans la console pour afficher la valeur.

- **des opérations sur les objets en mémoire** :
    + la fonction `ls()``r .fun("ls", bold = TRUE)` affiche tous les objets en mémoire ;
    + la fonction `str(a)``r .fun("str", bold = TRUE)` affiche les caractéristiques (ou encore la *structure*) de l'objet `a` (son type, sa longueur, etc.) ;
    + la fonction `rm(a)``r .fun("rm", bold = TRUE)` supprime l'objet `a`.
    
- **des requêtes pour l'aide** : pour afficher l'aide sur une fonction dont le nom est `maFonction`, il suffit d'utiliser `help(maFonction)``r .fun("help", bold = TRUE)` ou plus simplement `? maFonction``r .fun("?", bold = TRUE)`.

- **des opérations simples** : le tableau ci-dessous présente quelques opérations arithmétiques et les symboles correspondant en R.

    Code R     | Résultat
    ------------- | -------------
    `a + b``r .fun("+", bold = TRUE)`       | Somme de a et b
    `a - b``r .fun("-", bold = TRUE)`       | Soustraction de b à a
    `a * b``r .fun("*", bold = TRUE)`       | Produit de a et b
    `a / b``r .fun("/", bold = TRUE)`       | Division de a par b
    `a ^ b``r .fun("\\textasciicircum", bold = TRUE)`    | a puissance b
    `a %/% b``r .fun("\\%/\\%", bold = TRUE)`   | Quotient de la division euclidienne de a par b
    `a %% b``r .fun("\\%\\%", bold = TRUE)`    | Reste de la division euclidienne de a par b
    `sqrt(a)``r .fun("sqrt", bold = TRUE)`     | Racine carrée de a



```{r, results = "asis", echo = FALSE}
.question("Convertir une durée de secondes en minutes-secondes")
```
Il est souvent très utile de mesurer et d'afficher la durée d'un traitement un peu long (script exécuté régulièrement par exemple). La fonction `system.time()``r .fun("sys.time", bold = TRUE)` de R n'affiche néanmoins que le temps écoulé en *secondes*, ce qui n'est guère lisible. **L'objectif de ce cas pratique est de convertir une durée de secondes en minutes-secondes**.

a. Ouvrez une session AUS (en utilisant votre idep et votre mot de passe) et lancez le programme R (pas Rstudio).

b. Dans la console, associez la valeur 2456 à l'objet `duree`.  C'est sur cette durée (en secondes) que vont porter tous les calculs. Une fois assignée, rappelez la valeur de `duree` dans la console.`r .fun("<-")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Note : Pour copier-coller les éléments de solution,
    # vous pouvez utiliser les raccourcis clavier Ctrl + C
    # (copier) et Ctrl + V (coller).
    
    # Pour assignez une valeur à un objet, on utilise l'opérateur <-
    duree <- 2456
    # Pour soumettre une opération en mode console, il suffit d'appuyer
    # sur ENTREE.
    
    # Dès lors qu'une valeur est assignée à un objet, il suffit de taper
    # le nom de l'objet dans la console pour rappeler sa valeur :
    duree
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Calculez le nombre de minutes correspondant à la valeur de `duree`. Comment obtenir un nombre entier (*cf.* le tableau des opérations arithmétiques) ? Associez cette valeur à l'objet `min`.`r .fun("/")``r .fun("\\%/\\%")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Pour obtenir le nombre de minutes dans duree, il suffit de
    # diviser par 60 :
    duree / 60
    # Néanmoins, pour obtenir un nombre entier de minutes, il faut utiliser
    # la division euclidienne (cf. tableau)
    duree %/% 60
    # On stocke le nombre de minutes dans l'objet min avec <-
    min <- duree %/% 60
    min
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

d. Calculez le nombre de secondes restantes une fois le nombre de minutes déterminé. Vous pouvez utiliser la flèche $\uparrow$ du clavier pour rappeler et modifier le code que vous venez de soumettre. Associez cette valeur à l'objet `sec`.`r .fun("\\%\\%")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Calculer le nombre de secondes restantes revient à calculer
    # le reste de la division euclidienne de duree par 60 : c'est ce
    # que fait l'opérateur %% (cf. tableau).
    duree %% 60
    # A nouveau, on rappelle le code saisi précédemment avec la flèche
    # HAUT du clavier et on associe la valeur à l'objet sec avec l'opérateur <-.
    sec <- duree %% 60
    sec
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

e. Utilisez la fonction `help()` (ou de façon équivalente `?`) pour recherchez de l'aide sur la fonction `paste()``r .fun("help")``r .fun("?")``r .fun("paste")`. Que se passe-t-il quand vous soumettez le code 
    ```{r, eval = FALSE}
paste("La durée est de", duree, "secondes.")
    ``` 
    En utilisant tous ces éléments, afficher dans la console le texte :
    ```{r, echo = FALSE, comment = ""}
"Le traitement a duré 40 minutes et 56 secondes."
    ```
    
    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval = FALSE}
    # Pour consulter l'aide de R, il suffit d'utiliser la fonction help()
    # avec entre parenthèses le nom de la fonction sur laquelle on souhaite
    # obtenir de l'aide. 
    help(paste)
    # On peut aussi plus simplement utiliser ? :
    ? paste
    # Un navigateur s'ouvre alors pour afficher la page d'aide de la fonction.
    ```
    ![Aide de la fonction paste()](../figures/Aide_paste.png)
    ```{r}
    # On y apprend que cette fonction sert à concaténer des "vecteurs"
    # (cf. module 2 de la formation). En soumettant l'exemple proposé,
    # on obtient :
    paste("La durée est de", duree, "secondes.")
    
    # Ce code produit une chaîne de caractère : les chaînes de texte
    # (entre "") sont reproduites telles quelles mais l'objet `duree`
    # est remplacé par sa valeur. Les différents arguments de la fonction
    # paste() sont séparés par des virgules.
    
    # Pour répondre à la question, il suffit donc d'utiliser les objets
    # `min` et `sec` définis précédemment comme arguments de la fonction paste() :
    paste("Le traitement a duré", min, "minutes et", sec, "secondes.")
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

```{r, results = "asis", echo = FALSE}
.question("Manipuler des objets en mémoire")
```
Par défaut en mode console, l'utilisateur ne dispose d'aucune information sur les objets stockés en mémoire. **L'objectif de ce cas pratique est de vous familiariser avec les principales fonctions de manipulation des objets en mémoire.**

a. Utilisez la fonction `ls()``r .fun("ls")` (sans argument) pour afficher les objets actuellement stockés en mémoire. Affectez la valeur 567 à l'objet `Duree` (avec un `D` majuscule) et relancez la fonction `ls()`. Pourquoi R distingue-t-il les objets `duree` et `Duree` ?

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Utilisée sans arguments, la fonction ls() liste tous les objets 
    # stockés dans l'environnement de travail de R
    ls()
    Duree <- 567
    ls()
    # R distingue les objets duree et Duree car il est sensible à la casse.
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

b. Associez à l'objet `monTexte` la chaîne de caractère `"Hello world!"`. En utilisant la fonction `str()``r .fun("str")`, comparez les caractéristiques des objets `duree` et `monTexte`. À quel type chacun de ces deux objets appartient-il ?

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Comme dans la fonction paste(), la manipulation de chaînes 
    # de caractère nécessite l'utilisation de guillemets ""
    monTexte <- "Hello world!"
    ls()
    
    # La fonction str(a) permet d'afficher les caractéristiques
    # de l'objet a.
    str(duree)
    str(monTexte)
    # duree est un objet de type numérique alors que
    # monTexte est un objet de type caractère.
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Utilisez la fonction `rm()``r .fun("rm")` pour supprimer les objets `Duree` et `monTexte`. Vérifiez que la suppression est effective (et  n'a pas affecté `duree`) en relançant la fonction `ls()``r .fun("ls")`.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Objets présents au début de la question
    ls()
    
    # La fonction rm() (de l'anglais remove) permet de supprimer 
    # un ou plusieurs objets.
    rm(Duree, monTexte)
    ls()
    # Les objets Duree et monTexte ont bien été supprimés.
    ```
    ```{r,results = "asis",echo = FALSE}
    .endsol()
    ```

d. Recherchez de l'aide sur la fonction `rm()``r .fun("rm")`, et plus spécifiquement sur son argument `list`. En utilisant cet argument combiné avec la fonction `ls()``r .fun("ls")`, écrivez une instruction qui supprime tous les objets dans l'environnement de travail de R.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval = FALSE}
    # Pour recherchez de l'aide sur une fonction, on utilise tout simplement ?
    ? rm
    ```
    ![Aide de la fonction rm()](../figures/Aide_rm.png)
    ```{r}
    # L'argument list permet de spécifier les objets à supprimer
    # sous la forme d'une vecteur de type caractère. Or c'est précisément
    # ce que produit la fonction ls() :
    ls()
    
    # Pour supprimer tous les éléments en une seule commande, il suffit
    # de spécifier le résultat de la commande ls() à l'argument list de la
    # fonction rm() :
    rm(list = ls())
    
    # On vérifie alors qu'il n'y a plus aucun objet 
    # dans l'environnement de travail :
    ls()
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```


```{r, results = "asis", echo = FALSE}
.souspartie("Utiliser des scripts dans RStudio")
```

Quoique toutes les fonctionnalités de R soient accessibles en mode console, ce type d'interface présente l'inconvénient majeur de **ne pas permettre de garder facilement une trace du code saisi** (sinon par le biais de l'historique des commandes accessible par $\uparrow$). Pour combler ce manque, les différentes interfaces graphiques de R permettent d'utiliser des **scripts** au format `.R`, à l'image des éditeurs de SAS (fichiers `.sas`) ou des *do-file* de Stata (fichiers `.do`).

En particulier, l'environnement de développement **RStudio** propose de nombreuses fonctionnalités qui **rendent l'utilisation de R beaucoup plus simple et intuitive** : explorateur d'environnements, colorisation et auto-complétion du code, afficheur de fenêtres d'aide et de résultats, etc.

![Interface fenêtrée de **RStudio** sous Windows](../figures/Interface_RStudio_1.png)

À l'ouverture de **RStudio**, en règle générale trois panneaux sont visibles :

- La **console** (à gauche par défaut) : la principale différence avec précédemment tient à la couleur du texte, noire pour les messages et bleue pour le signe `>`. Pour vider l'intégralité de la console, taper `Ctrl + L`.
- L'**explorateur d'environnements et l'historique** (en haut à droite par défaut) : l'explorateur d'environnements permet notamment d'afficher, comme la fonction `ls()`, les objets présents dans l'environnement de travail (ou "environnement global"); comme la touche $\uparrow$ dans la console, l'historique rappelle toutes les commandes saisies.
- La **fenêtre de visualisation** (en bas à droite par défaut) : ce panneau intègre à la fenêtre du logiciel l'aide ou encore les graphiques produits.

En appuyant sur "Nouveau" > "Script R" (bouton entouré en rouge dans la figure précédente), les fenêtres se réorganisent pour faire apparaître une zone de texte : l'**éditeur de script**.

![Interface fenêtrée de **RStudio** sous Windows -- Avec éditeur de scripts ouvert](../figures/Interface_RStudio_2.png)

L'utilisation de l'éditeur de scripts sous **RStudio** est analogue à celle de l'éditeur sous SAS ou du *do-file editor* de Stata :

- il est possible d'**enregistrer** et d'**ouvrir un script** avec les boutons de la barre d'outils correspondants. Le format d'enregistrement par défaut est `.R`, mais le fichier est directement lisible par n'importe quel éditeur de texte (bloc-note ou Notepad++ sous Windows par exemple) ;
- pour **soumettre une ou plusieurs lignes de code**, il suffit de les sélectionner et de saisir au clavier **Ctrl\ +\ R** ou **Ctrl\ +\ Entrée** ;
- les **éléments de syntaxe apparaissent en couleur** : les commentaires (précédés de `#` à chaque ligne) en vert clair, les objets en noir, les nombres en bleu et les chaînes de caractère (entre `""` ou `''`) en vert foncé. Pour **commenter plusieurs lignes de code simultanément**, il suffit d'utiliser le raccourci **Ctrl\ +\ Maj\ +\ C**;
- des **suggestions apparaissent au cours de la frappe** : quand **RStudio** détecte le début du nom d'un objet déjà défini (par exemple une fonction), il fournit des **propositions d'auto-complétion**. Le logiciel double également automatiquement les guillemets et les parenthèses.

```{r, results = "asis", echo = FALSE}
.question("Construire une fonction de conversion de secondes en minutes-secondes")
```
Ce cas pratique reprend les éléments du cas pratique 1.1. Son objectif est de construire une fonction `conversion()` qui, à partir d'un paramètre `duree` exprimé en secondes, crée une chaîne de caractère du type
```{r, echo = FALSE, comment = ""}
"Le traitement a duré `min` minutes et `sec` secondes."
```

\ 

a. Toujours sur AUS, ouvrez le programme **RStudio**. Créez un nouveau script et sauvegardez-le par exemple sous votre répertoire personnel `U:\`.

b. En vous inspirant de l'exemple de la fonction `monCalcul()` (*cf.* *supra*), écrivez dans le script une première version de la fonction `conversion()` qui, à partir du paramètre `duree`, affiche le temps en secondes correspondant (sans le modifier dans un premier temps).`r .fun("function")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # La structure de base d'une définition de fonction est simple :
    # l'opérateur d'assignation est utilisé pour associer à un nom
    # le code de la fonction
    conversion <- function(duree){
      return(duree)
    }
    # Dans cette première version, on ne fait que renvoyer la valeur
    # de duree à l'identique.
    conversion(2456)
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Intégrez à la fonction `conversion()` les éléments définis aux différentes étapes du cas pratique 1.1 (définition de `min`, de `sec`, concaténation avec la fonction `paste()`) pour atteindre le résultat désiré. Testez votre fonction avec les valeurs 2456 et 7564.`r .fun("function")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # On reprend les éléments du cas pratique 1.1 pour rendre la fonction
    # véritablement opérante :
    conversion <- function(duree){
      min <- duree %/% 60
      sec <- duree %% 60
      resultat <- paste(
        "Le traitement a duré", min, "minutes et", sec, "secondes."
      )
      return(resultat)
    }
    conversion(2456)
    conversion(7564)
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

d. Observez comment l'éditeur colorise votre code, mais aussi les différents objets créés dans l'explorateur d'environnements. Saisissez dans l'éditeur ou la console les lettres `conver` et utilisez l'auto-complétion pour sélectionner votre fonction. Ajoutez des commentaires (précédés par `#`), manuellement ou en utilisant le raccourci clavier Ctrl\ +\ Maj\ +\ C.

\ 



```{r, results = "asis", echo = FALSE}
.partie("Charger et explorer des données")
```


**Explorer des données statistiques avec R est relativement intuitif**, en particulier grâce aux fonctionnalités de RStudio : affichage des objets chargés en mémoire, explorateur d'objets, auto-complétion. **Manipuler des données exige en revanche une plus grande maîtrise des briques élémentaires du langage** qui sont présentées en détails dans le `r .ref("module 2", "module2.html")` de la formation.

\ 

R travaille sur des **objets stockés en mémoire** : pour explorer des données, la première étape consiste donc à les **charger en mémoire depuis leur emplacement sur le disque dur de l'ordinateur**. On utilise en général pour ce faire la **fonction `load()`**`r .fun("load", bold = TRUE)`: 

```{r, eval=FALSE}
# Chargement des données du fichier module1.RData
load("Y:/Documentation/R/R_initiation/donnees/module1.RData")
# NOTE : DANS R LES CHEMINS SONT INDIQUES AVEC DES / ET NON DES \
```
```{r, echo=FALSE}
load("module1.RData")
```

**La fonction `load()` charge dans l'environnement de travail les objets contenus dans le fichier `module1.RData`** en les décompressant au passage (par défaut les fichiers saugevardés par R sont compressés). L'environnement de travail comporte désormais deux nouveaux objets :

```{r}
# Fichiers présents dans l'environnement de travail
ls()

# Caractéristiques de l'objet bpe
str(bpe)
```

**L'objet `bpe` correspond à une extraction de la [Base permanente des équipements 2015](https://www.insee.fr/fr/statistiques/2410933) restreinte aux équipements de la ville de Malakoff (code Insee 92046)**. La nomenclature des équipements est présentée sur [cette page](https://www.insee.fr/fr/statistiques/2578377).

Pour parcourir ce fichier dans **RStudio**, il suffit de **cliquer sur son nom dans l'explorateur d'environnements**. Plusieurs manipulations peuvent par ailleurs être effectuées de façon relativement intuitive: 

\ 

- **afficher les premières lignes** avec la fonction `head()`, les **dernières lignes** avec la fonction `tail()``r .fun("head", bold = TRUE)``r .fun("tail", bold = TRUE)` :
    ```{r}
# Affichage des premières et dernières lignes de l'objet bpe
head(bpe)
tail(bpe)
    ```

\ 

- **accéder au contenu d'une variable avec l'opérateur `$`**`r .fun("\\$")` (ici uniquement les 20 premières valeurs pour des raisons de présentation) :
    ```{r, eval = FALSE}
# Affichage des premières de la variable codant le type d'équipement
bpe$typequ
    ```

    ```{r, echo = FALSE}
bpe$typequ[1:20]
    ```

\ 

- **calculer le total et des statistiques descriptives** sur une variable de nature quantitative avec les fonctions `sum()``r .fun("sum")` et `summary()``r .fun("summary")` :
    ```{r}
# Total et distribution de la variable dénombrant le nombre d'équipements
# par iris et par type
sum(bpe$nb_equip)
summary(bpe$nb_equip)
    ```

\ 

- **déterminer les modalités distinctes et tabuler** une variable de nature qualitative avec les fonctions `unique()``r .fun("unique")` et `table()``r .fun("table")` :
    ```{r}
# Liste des iris associés à la commune de Malakoff
unique(bpe$dciris)

# Nombre de types d'équipements distincts par iris à Malakoff
table(bpe$dciris)
    ```

\ 

- **faire des représentation graphiques simples** avec les fonctions `pie()``r .fun("pie")`, `barplot()``r .fun("barplot")` et `plot()``r .fun("plot")` :
    ```{r bpe_pie, fig.align="center"}
# Représentation du nombre de type d'équipement par iris
pie(
  table(bpe$dciris)
  , main = "Nombre de types d'équipements par iris\nde la ville de Malakoff"
)
    ```

------

**Remarque** D'un point de vue technique, **l'objet `bpe` est de type `data.frame`**, qui correspond au format le plus fréquent pour les tables de données dans R. Ce type d'objet est **relativement complexe et est présenté en détails dans le `r .ref("module 3", "module3.html")` de la formation**.

------

<!-- **Note** Au-delà de l'opérateur `$`, il existe de très nombreuses manières de sélectionner des variables dans un `data.frame`. -->
<!-- ```{r} -->
<!-- # Sélection des premières valeurs de la variable -->
<!-- # typequ par plusieurs méthodes -->
<!-- head(bpe$typequ) -->
<!-- head(bpe[, "typequ"]) -->
<!-- head(bpe[, 7]) -->
<!-- head(bpe[["typequ"]]) -->
<!-- head(bpe[[7]]) -->
<!-- head(bpe["typequ"]) -->
<!-- head(bpe[7]) -->
<!-- # Note : la fonction head est utilisée ici pour limiter -->
<!-- # l'affichage aux premières valeurs de la variable uniquement -->
<!-- ``` -->
<!-- Ces possibilités multiples sont à mettre sur le compte de la **relative complexité du type d'objet `data.frame`**. **L'objectif du module 2 de la formation est de présenter un à un les types d'objets les plus courants (vecteurs, matrices, listes) et leurs relations, afin d'éclairer le comportement particulier du type `data.frame`** lors du module 3. -->

```{r, results = "asis", echo = FALSE}
.question("Charger et explorer des données : Le recensement de la population 2013 dans les Hauts-de-Seine")
```
Ce cas pratique vise à charger et à effectuer **quelques manipulations simples sur une extraction du fichier du recensement de la population (RP) 2013 dans les Hauts-de-Seine** (accessible sur le [site de l'Insee](https://www.insee.fr/fr/statistiques/2409491)). Les données ont été préalablement téléchargées et converties (*cf.* sous-partie suivante) et sont contenues dans le fichier `module1.RData`.

a. Utilisez la fonction `load()``r .fun("load")` pour charger les données contenues dans le fichier `Y:\Documentation\R\R_initiation\donnees\module1.RData`. **Pensez à bien utiliser des `/` et non des `\` dans le chemin du fichier** (sans quoi le chargement ne fonctionnera pas). Affichez les caractéristiques de l'objet `rp` : combien ce fichier comporte-t-il d'observations et de variables ? Affichez ses premières lignes.`r .fun("head")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval=FALSE}
    # Chargement du fichier exemples.RData
    load("Y:/Documentation/R/R_initiation/donnees/module1.RData")
    # NOTE : DANS R LES CHEMINS SONT INDIQUES AVEC DES / ET NON DES /
    ```
    ```{r, echo=FALSE}
    load("module1.RData")
    ```
    ```{r}
    # Objets présents dans l'environnement de travail
    ls()
    
    # Caractéristiques de l'objet rp
    str(rp)
    # Le fichier rp comporte 609 446 observations et 6 variables
    
    # Pour afficher les premières lignes d'une table, on utilise
    # la fonction head()
    head(rp)
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

b. Utilisez l'opérateur `$``r .fun("\\$")` pour afficher les valeurs de la variable de pondération `IPONDI`. Pensez à bien respecter la casse du nom de la variable. Appliquez la fonction `sum()``r .fun("sum")` à la variable `IPONDI` pour déterminer la population totale des Hauts-de-Seine au sens du RP 2013 (*i.e.* calculer la somme de la variable `IPONDI`).

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval = FALSE}
    # Affichage du contenu de la variable IPONDI
    rp$IPONDI
    # Note : pour des raisons de présentation, seules les 20 premières valeurs
    # sont affichées ici.
    ```
    
    ```{r, echo = FALSE}
    rp$IPONDI[1:20]
    ```
    
    ```{r}
    sum(rp$IPONDI)
    # La population des Hauts-de-Seine au sens du RP 2013 est de
    # 1 591 365 habitants.
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Affichez les modalités distinctes de la variable `SEXE``r .fun("unique")`. Appliquez la fonction `table()``r .fun("table")` à cette variable pour déterminer la répartition par sexe des individus recensés. Utilisez la fonction `pie()``r .fun("pie")` pour représenter cette répartition.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Pour afficher les modalités distinctes d'une variable, on utilise
    # la fonction unique()
    unique(rp$SEXE)
    # Comme souvent, le sexe est codé par un chiffre, "1" pour
    # les hommes et "2" pour les femmes.
    table(rp$SEXE)
    # La fonction table() permet d'effectuer une tabulation
    # simple (et non pondérée) d'une variable
    
    # Pour représenter cette répartition, il suffit d'utiliser la fonction
    # pie() avec comme données le résultat de la fonction table()
    pie(
      table(rp$SEXE)
      , main = "Sexe des individus recensés au RP 2013"
    )
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```


```{r, results = "asis", echo = FALSE}
.partie("Importer des données à l'aide de *packages*")
```

En règle générale, les fichiers de données sur lesquels on souhaite travailler ne sont pas en format R natif : il convient donc de les **importer**. **R dispose de très nombreuses fonctions pour importer des données provenant d'autres logiciels** (notamment SAS). Toutes ne sont cependant pas chargées par défaut au démarrage du logiciel, mais sont facilement accessibles par le biais de *packages*.

Le "fil rouge" de cette sous-partie est l'**importation d'autres données de la Base permanente des équipements** (relatives à Montrouge, code Insee 92049) **et stockées dans différents formats** (`bpe2.csv`, `bpe2.sas7bdat`). **L'utilisation des *packages* est présentée en parallèle**.

------

**Remarque** Pour faciliter l'import de plusieurs fichiers, on modifie le **répertoire de travail** (*working directory*) **de R** : il s'agit du répertoire dans lequel le logiciel **recherche par défaut les fichiers sur lesquels travailler**. Une fois le répertoire de travail convenablement défini (avec la fonction `setwd()``r .fun("setwd", bold = TRUE)`), il suffit de saisir le nom du fichier à importer pour que R le trouve automatiquement `r .fun("load")`: 

```{r, eval = FALSE}
# Définition du répertoire de la formation comme répertoire de travail
setwd("Y:/Documentation/R/R_initiation/donnees")

# Utilisation de la fonction load() sans avoir à indiquer le chemin
load("module1.RData")
```

------

```{r, results = "asis", echo = FALSE}
.souspartie("Importer des fichiers plats avec `read.table()`")
```

R dispose nativement d'un fonction capable de lire les fichiers dits "plats" (`.txt`, `.csv` ou `.dlm` le plus souvent) : la **fonction `read.table()`**`r .fun("read.table", bold = TRUE)` (taper `? read.table` pour afficher sa page d'aide). Cette fonction comporte un grand nombre de paramètres susceptibles d'être ajustés au format du fichier en entrée : délimiteur, séparateur de décimales, etc.

Afin de faciliter l'utilisation de cette fonction, des fonctions "alias" sont également disponibles qui correspondent à des **versions pré-paramétrées de `read.table()`**. En particulier :

- `read.csv()``r .fun("read.csv", bold = TRUE)` importe des fichiers dont les colonnes sont **séparées par des virgules** ;
- `read.delim()``r .fun("read.delim", bold = TRUE)` importe des fichiers dont les colonnes sont **séparées par des tabulations**.

Les colonnes du fichier `bpe2.csv` utilisé dans cet exemple sont **séparées par des virgules** (comme ceux des fichiers produits par défaut par LibreOffice Calc) : c'est donc la fonction `read.csv()` qu'il convient d'utiliser :
```{r}
# Chargement du fichier bpe2.csv
bpe2_csv <- read.csv("bpe2.csv")
# Remarque : le fichier bpe2.csv est dans le répertoire de travail
# (modifié plus haut à l'aide de setwd()) donc il suffit d'indiquer 
# son nom pour que R le retrouve. 

# Premières lignes de bpe2_csv
head(bpe2_csv)
```


<!-- ```{r, results = "asis", echo = FALSE} -->
<!-- .souspartie("Importer des fichiers `.dbf` ou `.dta` avec le *package* `foreign`") -->
<!-- ``` -->

<!-- Au-delà des fonctions natives de R, plusieurs *packages* permettent d'importer facilement des données dans R, dont le *package* `foreign`. Dans **RStudio**, la sous-fenêtre *Packages* de la fenêtre de visualisation (en bas à droite par défaut) permet d'afficher l'ensemble des *packages* installés avec une description succincte. -->

<!-- ![Interface fenêtrée de **RStudio** sous Windows -- Liste des *packages* installés](../figures/Interface_RStudio_3.png) -->

<!-- Le *package* `foreign` a la particularité d'être **pré-installé** : pour utiliser ses fonctions, il suffit de le charger avec la fonction `library()` (une fois par session suffit). -->

<!-- ```{r} -->
<!-- # Chargement du package foreign -->
<!-- library("foreign") -->
<!-- ``` -->
<!-- Dans **RStudio**, cocher la case devant le nom du *package* génère automatiquement une ligne de code équivalente. -->

<!-- \ -->

<!-- Dès lors qu'il est chargé, les fonctions d'import de données du *package* `foreign` sont accessibles, par exemple depuis un fichier au format `.dbf` (la plupart des fichiers "détails" mis en ligne sur le site de l'Insee sont des `.dbf` zippés)`r .fun("read.dbf", bold = TRUE)` : -->

<!-- ```{r} -->
<!-- # Chargement du fichier bpe2.dbf -->
<!-- bpe2_dbf <- read.dbf("bpe2.dbf") -->

<!-- # Premières lignes de bpe2_dbf -->
<!-- head(bpe2_dbf) -->
<!-- ``` -->

<!-- Le package `foreign` permet également d'importer des fichiers `.dta` (fichiers de données Stata, version 5-12), mais aussi d'exporter des fichiers `.dbf` et `.dta` avec les fonctions `write.dbf()``r .fun("write.dbf", bold = TRUE)` et `write.dta()``r .fun("write.dta", bold = TRUE)` respectivement : -->

<!-- ```{r} -->
<!-- # Export du fichier bpe2_dbf en .dta -->
<!-- write.dta(bpe2_dbf, file = "bpe2.dta") -->
<!-- # Note : par défaut les fichiers produits par un code R sont -->
<!-- # créés dans le répertoire de travail, ici U:\R_initiation\donnees. -->
<!-- ``` -->


```{r, results = "asis", echo = FALSE}
.souspartie("Importer des fichiers `.sas7bdat` avec le *package* `haven`")
```

Au-delà des fonctions natives de R, plusieurs *packages* permettent d'importer facilement des données dans R, comme le *package* `haven` pour les fichiers de données SAS en format `.sas7bdat` (entre autres). Dans **RStudio**, la sous-fenêtre *Packages* de la fenêtre de visualisation (en bas à droite par défaut) permet d'afficher l'ensemble des *packages* installés avec une description succincte.

![Interface fenêtrée de **RStudio** sous Windows -- Liste des *packages* installés](../figures/Interface_RStudio_3.png)

Une des principaux avantages de R est de disposer d'un très grand nombre de *packages* complémentaires (`r formatC(dim(available.packages())[1],big.mark = "\\ ")` au `r format(Sys.Date(), "%d/%m/%Y")`) très faciles à installer. Pour installer un package, il suffit en effet de saisir: 

```{r, eval=FALSE}
# Installation du package haven
install.packages("haven")
# Remarque : A ne faire qu'une seule fois
```

------

**Remarque** Lors de l'installation d'un package, il arrive qu'une **fenêtre apparaisse pour demander de choisir un "miroir" pour le téléchargement des fichiers**. Comme pour la plupart des logiciels libres, les éléments constitutifs de R ne sont pas disponibles sur un seul serveur mais sur une multitude de serveurs identiques (d'où le nom "miroir"), en général maintenus par des universités ou des institutions de recherche. N'importe quel "miroir" peut donc faire l'affaire, mais il est courant de privilégier le serveur le plus proche géographiquement (plusieurs miroirs sont situés à Paris).

Si nécessaire, le programme télécharge et installe également, en plus du *package* demandé, l'ensemble des **dépendances** indispensables à son fonctionnement. **Il est en effet fréquent qu'un *package* s'appuie sur des fonctionnalités proposées par d'autres *packages* non pré-installés par défaut**. Pour connaître la liste des dépendances d'un *package*, il suffit de consulter les rubriques *Depends* et *Imports* de sa page de référence sur le *Comprehensive R Archive Network* (CRAN). Par exemple pour le *package* `haven` : https://CRAN.R-project.org/package=haven

------

\ 

**Le *package* `haven` est pré-installé sous AUS**, il n'est donc pas nécessaire de le réinstaller. Pour utiliser les fonctionnalités qu'il apporte, **il suffit de le charger avec la fonction** `library()``r .fun("library", bold = TRUE)` (à faire à chaque session de travail avec le *package*) :

```{r}
# Chargement du package haven
library(haven)
# Remarque : A faire à chaque session de travail avec le package
```

Pour importer des fichiers `.sas7bdat` dans R, il ne reste donc plus qu'à utiliser la fonction `read_sas()``r .fun("read\\_sas", bold = TRUE)` qu'apporte le *package* `haven`.

```{r}
# Import du fichier bpe2.sas7bdat
bpe2_sas <- read_sas("bpe2.sas7bdat")

# Premières lignes de bpe2_sas
head(bpe2_sas)
```

```{r, results = "asis", echo = FALSE}
.souspartie("Sauvegarder des données en format R natif")
```

Une fois des données importées, il est souvent utile de les **sauvegarder sur le disque dur dans un format susceptible d'être lu rapidement par R** à l'aide de la fonction `save()``r .fun("save", bold = TRUE)`. 

La fonction `save()` est le **pendant de la fonction `load()`**. Elle permet de **sauvegarder un ou plusieurs fichiers** que la fonction `load()``r .fun("load")` recharge tels quels (en particulier avec le même nom) dans l'environnement de travail :

```{r}
# Sauvegarde des fichiers importés dans le fichier bpe2.RData
save(bpe2_csv, bpe2_sas, file = "bpe2.RData")

# Suppression des fichiers bpe2_csv et bpe2_sas
rm(bpe2_csv, bpe2_sas)
ls()

# Chargement du fichier bpe2.RData
load("bpe2.RData")
ls()
```

Les fichiers `.RData` sauvegardés sont **compressés par défaut**, ce qui diminue considérablement leur taille sur le disque.


```{r, results = "asis", echo = FALSE}
.question("Importer et sauvegarder des données")
```
Les **données du [Code officiel géographique](https://www.insee.fr/fr/information/2666684)** (COG) sont diffusées sur le site de l'Insee en plusieurs formats (notamment `.txt`). Ce cas pratique vise à importer ces données dans R et à les sauvegarder en format R natif.

a. On cherche à importer le fichier `depts2017.txt`.
Il s'agit d'un fichier dont les colonnes sont séparées par des tabulations `\t` : quelle fonction semble adaptée selon vous pour importer ce fichier ? Utilisez-la pour lire ce fichier dans l'objet `dep`. Affichez-en les caractéristiques ainsi que les premières lignes.`r .fun("read.delim")` 

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Les colonnes du fichier étant séparées par des tabulations, 
    # c'est la fonction read.delim() qui est la plus adaptée.
    dep <- read.delim("depts2017.txt")
    str(dep)
    head(dep)
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

b. Le fichier `arrond2017.sas7bdat` correspond à la table des arrondissements convertie au format `.sas7bdat`. Utilisez le *package* `haven` pour importer ce fichier dans l'objet `arrond`. Affichez-en les caractéristiques et les premières lignes.`r .fun("read\\_sas")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Chargement du package haven (pré-installé sur AUS)
    library(haven)
    
    # Remarque : si haven n'avait pas été pré-installé, il aurait
    # fallu l'installer avec 
    # install.packages("haven")
    
    # Utilisation de la fonction read_sas()
    arrond <- read_sas("arrond2017.sas7bdat")
    str(arrond)
    head(arrond)
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Sauvegardez les objets `dep` et `arrond` dans le fichier `U:\cog.RData` à l'aide de la fonction `save()``r .fun("save")`. Vérifiez que le fichier est bien créé dans le répertoire que vous avez indiqué et comparez sa taille sur le disque avec celle des fichiers `.csv` et `.sas7bdat` d'origine.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval=FALSE}
    # Sauvegarde des objets du COG dans cog.RData
    save(dep, arrond, file = "U:/cog.RData")
    ```
    ```{r, include=FALSE}
    save(dep, arrond, file = "cog.RData")
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

d. Supprimez l'ensemble des objets de l'environnement de travail puis rechargez les fichiers du COG en utilisant la fonction `load()``r .fun("load")` sur `cog.RData`. Vérifiez que les objets concernés sont bien de nouveau présent dans l'environnement de travail.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, eval=FALSE}
    # Suppression de tous les fichiers de l'environnement de travail
    rm(list = ls())
    ls()
    
    # Chargement des fichiers du COG
    load("U:/cog.RData")
    ls()
    ```
    ```{r, echo=FALSE}
    rm(list = ls())
    load("cog.RData")
    ls()
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```


------

**Remarque** Contrairement à un fichier `.sas7bdat` ou à un fichier `.csv`, **un fichier `.RData` peut contenir plusieurs fichiers de données différents** (par exemple toutes les tables du même millésime d'une enquête). 

Le **format `.rds`** (et les fonctions associées `saveRDS()``r .fun("saveRDS", bold = TRUE)` et `readRDS()``r .fun("readRDS", bold = TRUE)`) permet de retrouver dans R le mode de fonctionnement des autres logiciels statistiques, à savoir **un fichier de données par fichier sur le disque**: 

```{r}
# Sauvegarde de l'objet dep en .rds
saveRDS(dep, file = "dep.rds")

# Chargement du fichier dep.rds dans l'objet dep_bis
dep_bis <- readRDS("dep.rds")
str(dep_bis)

# Comparaison de dep et de dep_bis
identical(dep, dep_bis)
```

Quoique moins connues, on recommande souvent (par exemple [ici](http://www.fromthebottomoftheheap.net/2012/04/01/saving-and-loading-r-objects/)) de **privilégier les fonctions `saveRDS()`/`readRDS()` à `save()`/`load()`**, ne serait-ce que pour éviter les **conflits de noms** et les écrasements inintentionnels de données qui peuvent en résulter.

------

<!--chapter:end:01-prise-en-main.Rmd-->

```{r, include = FALSE}
rm(list = ls())
if(!exists(".initOK")) source("init.R", encoding = "latin1")
.init()
```

```{r, results = "asis", echo = FALSE}
.module(numModule = 2, "Manipuler les éléments fondamentaux du langage")
```

\ 

La philosophie de ce deuxième module diffère sensiblement de celle des modules 1 et 3. Son objectif est de vous amener à **manipuler les briques élémentaires du langage de R : vecteurs, matrices et listes**. À ce titre, il s'agit d'un détour indispensable avant d'aborder les opérations plus complexes portant sur les tables de données (sélection d'observations et de variables, tri, fusion, etc.). 

Plus encore que les autres modules, il est pensé pour **articuler étroitement apprentissage d'un "vocabulaire" de fonctions et mise en oeuvre autour de cas pratiques**. 

```{r, results = "asis", echo = FALSE}
.partie("Les vecteurs : création et sélection")
```

Les vecteurs constituent un des types d'objets les plus simples et les plus courants dans R. **Ils interviennent dans la manipulation de la plupart des autres types d'objets** et méritent à ce titre une attention particulière. 

**Exemples** Les variables d'une table sont des vecteurs, tout comme la plupart des paramètres passés à une fonction.

```{r, results = "asis", echo = FALSE}
.souspartie("Créer des vecteurs et connaître leurs caractéristiques")
```

La **fonction `c()`**`r .fun("c", bold = TRUE)` permet de créer des vecteurs : 
```{r}
# Création de vecteurs
c(8, 5)
c("z","B","e")
c(TRUE, FALSE, FALSE, TRUE)
```

Pour associer un vecteur à un nom d'objet, il suffit d'utiliser l'**opérateur d'assignation `<-`**`r .fun("<-")` : 
```{r}
# Assignation de vecteurs à des noms
a1 <- c(8, 5)
a2 <- c("z", "B", "e")
a3 <- c(TRUE, FALSE, FALSE, TRUE)

# Rappel de la valeur des vecteurs définis
a1
a2
a3
```

Un vecteur possède plusieurs caractéristiques essentielles (que l'on qualifie d'**attributs**) : 

- son **type** : les types les plus courants sont numérique, caractère et logique ;
- sa **longueur** : le nombre d'éléments qui le composent.

Il est possible d'afficher ces attributs avec les **fonctions `str()`, `mode()` et `length()`**`r .fun("str", bold = TRUE)``r .fun("mode", bold = TRUE)``r .fun("length", bold = TRUE)`.
```{r}
# Attributs de a1
str(a1)
mode(a1)
length(a1)

# Attributs de a2
str(a2)
mode(a2)
length(a2)

# Attributs de a3
str(a3)
mode(a3)
length(a3)

```

Les fonctions **`is.numeric()`, `is.character()` et `is.logical()`**`r .fun("is.numeric", bold = TRUE)``r .fun("is.character", bold = TRUE)``r .fun("is.logical", bold = TRUE)` permettent de tester si un vecteur est de type numérique, caractère ou logique respectivement.

```{r}
# Utilisation de is.numeric()
is.numeric(a1)
is.numeric(a2)
is.numeric(a3)

# Utilisation de is.character()
is.character(a1)
is.character(a2)
is.character(a3)

# Utilisation de is.logical()
is.logical(a1)
is.logical(a2)
is.logical(a3)
```

\ 

---------------------

**Remarques** : 

- Quand on souhaite créer un vecteur de longueur 1, la fonction `c()` est inutile. C'est ce qui a été fait pendant tout le `r .ref("module 1", "module1.html")` de la formation.`r .fun("identical", bold = TRUE)`
```{r}
# Création d'un vecteur de longueur 1
a4 <- 2
a5 <- c(2)
identical(a4, a5)
```

- Les vecteurs de type logique ne peuvent prendre que **deux valeurs** (en plus des valeurs manquantes `NA`, *cf. infra*) : vrai (`TRUE`) et faux (`FALSE`). **`TRUE` et `FALSE` sont des mots-clés spécifiques qui doivent être écrits intégralement en majuscules** : 
```{r, error = TRUE}
# Création d'un vecteur logique
a6 <- c(TRUE, FALSE, TRUE, TRUE)
a6
is.logical(a6)

# Quand TRUE et FALSE ne sont pas écrits intégralement 
# en majuscules, des erreurs surviennent
a7 <- c(True, fALSE, true,false)
# R recherche un objet dont le nom est `True` mais n'en 
# trouve aucun.
```

- Quand nombres, caractères ou valeurs logiques coexistent dans la définition d'un vecteur, des **conversions automatiques** sont opérées : 
```{r}
# Création d'un vecteur mélangeant nombres, caractères
# et valeurs logiques
a8 <- c("a", 2, "b", TRUE)
a8

# Des guillemets apparaissent autour des valeurs numériques
# ou logiques : le vecteur est de type caractère
is.character(a8)
```

---------------------

\ 

**La fonction `c()` permet également de créer un vecteur à partir de plusieurs autres**`r .fun("c")`. 
```{r}
# Création des vecteurs de type caractère a9 et a10
a9 <- c("a", "b", "c", "d")
a10 <- c("mais", "ou", "et", "donc", "or", "ni", "car")

# Concaténation avec la fonction c()
c(a9, a10)
c(a10, a9)
```

**La fonction `rep()` permet enfin de créer des vecteurs en répétant une ou plusieurs valeurs un certain nombre de fois**`r .fun("rep", bold = TRUE)`. 
```{r}
# Création d'un vecteur avec la fonction rep()
rep(1, times = 5)

# Quand le premier argument de rep() est un vecteur, 
# il est répété en entier
rep(c(1, 2), times = 5)

# Utilisé à la place de times = , l'argument each = 
# permet de répéter chaque élément et non le vecteur
# en entier
rep(c(1, 2), each = 5)
```


```{r,results = "asis", echo = FALSE}
.question("Créer des vecteurs et connaître leurs caractéristiques")
```

a. Devinez le type et la longueur des vecteurs définis par le code suivant, puis vérifiez-les en créant ces vecteurs et en utilisant les fonctions `str()``r .fun("str")`, `length()``r .fun("length")` et `mode()``r .fun("mode")`.
    ```{r}
b1 <- c(1, 2, 3)
b2 <- rep(c("aaa","bbb"), times = 2)
b3 <- c(TRUE, FALSE, TRUE)
b4 <- c("TRUE", "FALSE", "FALSE")
b5 <- c(b2, b4)
b6 <- c(b1, b3)
    ```
    
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    b1 <- c(1, 2, 3)
    # b1 est de type numérique et de longueur 3
    str(b1)
    mode(b1)
    length(b1)
    
    b2 <- rep(c("aaa","bbb"), times = 2)
    # b2 est de type caractère et de longueur 4
    str(b2)
    
    b3 <- c(TRUE, FALSE, TRUE)
    # b3 est de type logique et de longueur 3
    str(b3)
    
    b4 <- c("TRUE", "FALSE", "FALSE")
    # b4 est de type caractère et de longueur 3
    str(b4)
    # Note : les mots-clés TRUE et FALSE sont entre
    # guillemets, ils sont donc reconnus comme des 
    # caractères.
    
    b5 <- c(b2, b4)
    # b5 est de type caractère et de longueur 7
    str(b5)
    # Les deux vecteurs  b2 et b4 sont de type caractère
    # et respectivement de longueur 4 et 3
    
    b6 <- c(b1, b3)
    # b6 est de type numérique et de longueur 6
    str(b6)
    # b1 est de type numérique, b3 de type logique : 
    # b3 est converti en numérique (TRUE en 1 et 
    # FALSE en 0) avant la concaténation. 
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```



b. Utilisez la fonction `rep()``r .fun("rep")` pour créer la séquence `r rep(c(1, 2), times = 2)`. Utilisez de nouveau `rep()` pour créer la séquence `r rep(c(1, 2), each = 3)`. Combinez ces éléments pour créer la séquence `r rep(c(1, 2), each = 3, times = 2)`. 

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Utilisation de l'argument times = de rep()
    rep(c(1, 2), times = 2)
    
    # Utilisation de l'argument each = de rep()
    rep(c(1, 2), each = 3)
    
    # Deux possibilités ici : 
    # - enchasser le second appel de rep() dans le premier
    rep(rep(c(1, 2), each = 3), times = 2)
    # - utiliser directement rep() avec each = et times =
    rep(c(1, 2), each = 3, times = 2)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

<!-- c. (Optionnel) Créez la fonction `maSequence(x, y)` telle que `maSequence(c("a", "b"), c("c", "d"))` génère automatiquement la séquence`r .fun("rep")``r .fun("function")` :  -->
<!--     ```{r,echo = FALSE} -->
<!-- rep(c(rep(c("a", "b"), each = 2), rep(c("c", "d"), each = 3)), times = 2) -->
<!--     ``` -->

<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .beginsol() -->
<!--     ``` -->
<!--     ```{r} -->
<!--     # Dans l'exemple fourni, chaque élément du vecteur c("a", "b")  -->
<!--     # est répété deux fois et chaque élément du vecteur c("c", "d")  -->
<!--     # est répété trois fois. -->
<!--     rep(c("a", "b"), each = 2) -->
<!--     rep(c("c", "d"), each = 3) -->

<!--     # Puis l'ensemble de la séquence est répétée deux fois. -->
<!--     # On commence donc par concaténer les deux séquences -->
<!--     # élémentaires. -->
<!--     c(rep(c("a", "b"), each = 2), rep(c("c", "d"), each = 3)) -->

<!--     # Puis on utilise de nouveau rep(), avec l'argument times -->
<!--     rep( -->
<!--       c(rep(c("a", "b"), each = 2), rep(c("c", "d"), each = 3)) -->
<!--       , times = 2 -->
<!--     ) -->
<!--     # C'est bien le résultat attendu -->

<!--     # Pour créer une fonction, il suffit d'utiliser -->
<!--     # l'opérateur d'assignation <- avec le mot-clé function() -->
<!--     maSequence <- function(x, y){ -->

<!--     } -->

<!--     # Pour l'heure la fonction est vide et ne renvoie aucun -->
<!--     # résultat (NULL) -->
<!--     maSequence(c("a", "b"), c("c", "d")) -->

<!--     # Il suffit d'adapter le code développé avec c("a", "b") -->
<!--     # et c("c", "d") à l'intérieur de la fonction -->
<!--     maSequence <- function(x, y){ -->
<!--       resultat <- rep(c(rep(x, each = 2), rep(y, each = 3)), times = 2) -->
<!--       return(resultat) -->
<!--     } -->

<!--     # On vérifie que cela fonctionne -->
<!--     maSequence(c("a", "b"), c("c", "d")) -->

<!--     # On essaie avec d'autres arguments -->
<!--     maSequence(c(1, 2, 3), 4) -->
<!--     ``` -->
<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .endsol() -->
<!--     ``` -->



```{r, results = "asis", echo = FALSE}
.souspartie("Extraire les éléments d'un vecteur")
```

L'opérateur d'extraction `[` permet de sélectionner des éléments en utilisant leur **position dans le vecteur** :
```{r}
# Définition du vecteur c1
c1 <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
c1

# Sélection de l'élément en position 2
c1[2]

# Sélection de l'élément en position 5
c1[5]
```

Pour extraire plus d'une valeur à la fois, il suffit d'utiliser l'opérateur `[``r .fun("[", bold = TRUE)` avec le **vecteur des positions souhaitées** : 
```{r}
# Sélection des éléments en position 3 et 6
c1[c(3, 6)]
```

Pour sélectionner **toutes les valeurs sauf certaines**, il suffit de d'indiquer leur **position précédée de `-`**`r .fun("-")` : 
```{r}
# Sélection de tous les éléments SAUF celui en position 3
c1[-3]

# Sélection de tous les éléments SAUF ceux en position 2 et 7
c1[-c(2,7)]
```

\ 

Il est également possible de **définir des vecteurs dont chaque élément est nommé** : 
```{r}
# Création du vecteur numérique c2 nommé
c2 <- c("pierre" = 1, "feuille" = 2, "ciseaux" = 3)
c2
```

Il est alors possible d'**utiliser les noms pour sélectionner un ou plusieurs éléments** :
```{r}
# Sélection de l'élément associé au nom "pierre"
c2["pierre"]

# Sélection des éléments associés aux noms "ciseaux" et "feuille"
c2[c("ciseaux","feuille")]
```

Il est possible d'**afficher et de modifier les noms** associés à un vecteur en utilisant la **fonction `names()`**`r .fun("names", bold = TRUE)` : 

```{r}
# Affichage des noms associés au vecteur c2
names(c2)

# Modification des noms associés au vecteur c2
names(c2) <- c("rouge", "jaune", "bleu")
c2
```

\ 

------------

**Remarque importante** Les éléments d'un vecteur sont extraits **dans l'ordre dans lequel sont renseignés les positions ou les noms**.

```{r}
# On compare le résultat de c1[c(3, 6)] et de c1[c(6, 3)]
c1

c1[c(3, 6)]

c1[c(6, 3)]

# Cela est vrai également quand l'extraction est opérée par les noms
c2

c2[c("rouge", "jaune")]

c2[c("jaune", "rouge")]
```

**En cas de répétition d'une position ou d'un nom, l'élément du vecteur correspondant est répété dans le résultat** :

```{r}
c1[c(3, 3, 6, 6)]

c2[c("rouge", "jaune", "jaune", "rouge")]
```

Cette propriété est extrêmement importante, dans la mesure où c'est sur elle que repose les **opérations de tri de tables de données** *via* la fonction `order()` (*cf.* *infra* et `r .ref("module 3", "module3.html")`).

-------------------

\ 

```{r,results = "asis", echo = FALSE}
.question("Extraire les valeurs d'un vecteur")
```

a. On définit le vecteur numérique `d1` par `d1 <- c(2, 7, 5, 8)`. Sélectionnez l'élément en troisième position, puis les éléments en quatrième et deuxième positions (dans cet ordre). Sélectionnez enfin tous les éléments sauf celui en première position.`r .fun("[")`
    
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    d1 <- c(2, 7, 5, 8)
    d1
    
    # Sélection de l'élément en troisième position
    d1[3]
    
    # Sélection des éléments en quatrième et en deuxième
    # position (dans cet ordre)
    d1[c(4, 2)]
    
    # Sélection de tous les éléments sauf celui en
    # première position
    d1[-1]
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. On définit le vecteur logique `d2` nommé par `d2 <- c("a" = TRUE, "b" = FALSE, "c" = FALSE, "d" = TRUE, "e" = TRUE)`. Que signifient les lettres `"a"`, `"b"`, `"c"`, `"d"` et `"e"` dans la définition du vecteur ? Proposez deux méthodes pour sélectionner les éléments de `d2` situé en troisième et première position (dans cet ordre).`r .fun("[")`
    
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    d2 <- c("a" = TRUE, "b" = FALSE, "c" = FALSE, "d" = TRUE, "e" = TRUE)
    d2
    # Les lettres "a", "b", "c", "d" et "e" correspondent à des noms
    # associés aux éléments de d2
    
    # Sélection par les positions
    d2[c(3, 1)]
    # Remarque : on obtient bien un résultat différent de d2[c(1, 3)]
    d2[c(1, 3)]
    
    # Sélection par les noms
    d2[c("c", "a")]
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. Affichez le vecteur de noms associé au vecteur `d2` avec la fonction `names()``r .fun("names")`. Quel est le type de ce vecteur ? Modifiez le vecteur de noms associé au vecteur `d2` et remplacez le par `c(2011, 2012, 2013, 2014, 2015)`.
    
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Affichage du vecteur de noms et de ses caractéristiques
    # grâce à la fonction names()
    names(d2)
    str(names(d2))
    # Comme attendu, le vecteur de noms est de type caractère
    
    # Modification du vecteur de noms associés au vecteur
    # d2
    names(d2) <- c(2011, 2012, 2013, 2014, 2015)
    d2
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

d. (Optionnel) Que se passe-t-il quand vous saisissez `d2[c(2012, 2015)]``r .fun("[")`. Comment le comprenez-vous ? Quel code proposeriez-vous pour sélectionner les éléments dont les noms sont `"2012"` et `"2015"` ?
    
    ```{r,results = "asis", echo = FALSE}
    .indic("**Indication** Quel est le type du vecteur de noms associé à `d2` ?")
    ```
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    d2[c(2012, 2015)]
    
    # On obtient un vecteur comprenant deux valeurs NA (cf. infra)
    # et non le vecteur c(FALSE, TRUE) attendu.
    
    # Comme le vecteur c(2012, 2015) est un vecteur numérique, 
    # le logiciel essaie d'extraire les éléments et 2012ème et 
    # 2015ème position respectivement, qui n'existent pas.
    
    # Le vecteur de noms associé à d2 est de type caractère
    str(names(d2))
    
    # Il semblerait que le vecteur numérique c(2011, 2012, 2013, 
    # 2014, 2015) ait été converti en vecteur caractère au moment 
    # de son assignation comme vecteur de noms à d2. 
    
    # Pour utiliser des noms pour extraire des éléments de d2,
    # il suffit de les saisir comme des chaînes de caractères.
    d2[c("2012", "2015")]
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

```{r, results = "asis", echo = FALSE}
.partie("Les vecteurs : types et opérations")
```

```{r, results = "asis", echo = FALSE}
.souspartie("Manipuler des vecteurs logiques")
```

Les vecteurs logiques sont particulièrement importants dans la mesure où ils interviennent dans l'évaluation et l'utilisation d'**expressions logiques**. Comme la plupart des langages, R dispose d'opérateurs logiques lui permettant d'évaluer certaines expressions (*cf.* tableau). **Ces opérateurs ne sont rien d'autres que des fonctions dont le résultat est un vecteur logique**. 

**Code R**     | **Résultat** 
------------- | ------------- 
`a == 1``r .fun("==", bold = TRUE)`       | Renvoie `TRUE` si `a` vaut 1
`a != 1``r .fun("\"!=", bold = TRUE)`       | Renvoie `TRUE` si `a` est différent de 1
`a < 1``r .fun("<", bold = TRUE)`       | Renvoie `TRUE` si `a` est strictement inférieur à 1
`a <= 1``r .fun("<=", bold = TRUE)`       | Renvoie `TRUE` si `a` est inférieur ou égal à 1
`a > 1``r .fun(">", bold = TRUE)`       | Renvoie `TRUE` si `a` est strictement supérieur à 1
`a >= 1``r .fun(">=", bold = TRUE)`       | Renvoie `TRUE` si `a` est supérieur ou égal à 1
`a & b``r .fun("\\&", bold = TRUE)`     | Renvoie `TRUE` si `a` est `TRUE` **et** `b` est `TRUE`
`a | b``r .fun("\"|", bold = TRUE)`     | Renvoie `TRUE` si `a` est `TRUE` **ou** `b` est `TRUE`
`!a``r .fun("\"!", bold = TRUE)`     | Renvoie `TRUE` si `a` est `FALSE`, `FALSE` si `a` est `TRUE`
`a %in% c(1,2)``r .fun("\\%in\\%", bold = TRUE)`       | Renvoie `TRUE` si `a` vaut 1 ou 2

```{r}
# Définition du vecteur e1
e1 <- c(1, 2, 3, 4, 5)
e1

# Evaluation d'expressions logiques
e1 == 3

e1 != 3

e1 < 3

e1 <= 3

!(e1 <= 3)

e1 >= 1 & e1 < 4

e1 < 2 | e1 > 4

e1 %in% c(1, 3)
```

\ 

Les vecteurs logiques peuvent ainsi être utilisés dans de nombreuses situations : 

- **combinés avec la fonction `sum()`**`r .fun("sum")`, pour déterminer le nombre d'éléments d'un vecteur qui respectent une certaine condition : 
    ```{r}
e1
# Nombre d'éléments de e1 strictement inférieurs à 3
sum(e1 < 3)
    ```

- **combinés avec la fonction `which()`**`r .fun("which", bold = TRUE)`, pour récupérer la position des éléments d'un vecteur respectant une certaine condition : 
    ```{r}
e1
# Position des éléments de e1 strictement supérieurs à 2
which(e1 > 2)
    ```

- **combinés avec l'opérateur d'extraction `[`**`r .fun("[")`, pour sélectionner ou remplacer les éléments respectant une certaine condition :
    ```{r}
e1
# Sélection des éléments de e1 dont la valeur 
# est strictement inférieure à 3
e1[e1 < 3]

# Remplacement des éléments de e1 dont la valeur 
# est strictement inférieure à 3 par 0
e1[e1 < 3] <- 0
e1
    ```

\ 

-------------------

**À retenir** Il existe ainsi **trois méthodes pour extraire les éléments d'un vecteur *via* l'opérateur `[`**`r .fun("[")` : 

- utiliser un **vecteur de positions**;
- utiliser un **vecteur de noms** (quand des noms sont définis);
- utiliser un **vecteur logique de même longueur**.

```{r}
e2 <- c("a" = 1, "b" = 2, "c" = 3, "d" = 4, "e" = 5)
e2
# Objectif : extraire les éléments en 2ème et 5ème position de e2

# Méthode 1 : par les positions
e2[c(2, 5)]

# Méthode 2 : par les noms
e2[c("b", "e")]

# Méthode 3 : avec un vecteur logique de longueur 5
# (car e2 est de longueur 5)
e2[c(FALSE, TRUE, FALSE, FALSE, TRUE)]
```

**Les deux premières méthodes permettent de modifier l'ordre des éléments ou de les répéter, mais pas la troisième** : 

```{r}
e2

e2[c(2, 1, 2, 3, 1)]

e2[c("b", "a", "b", "c", "a")]

e2[c(TRUE, TRUE, TRUE, FALSE, FALSE)]
# Note : il est impossible de changer l'ordre dans lequel apparaissent
# les éléments extraits (ni de les répéter) quand on utilise un vecteur
# logique pour mener l'extraction.
```

L'utilisation de vecteurs logique pour extraire des valeurs est particulièrement importante, dans la mesure où elle intervient dans la plupart des opérations de **sélection d'observations ou de variables** dans une table de données (*cf.* *infra* et `r .ref("module 3", "module3.html")`).

------------
\ 


```{r,results = "asis", echo = FALSE}
.question("Manipuler des vecteurs logiques")
```

a. On définit le vecteur `f1 <- c(5, 2, -4, 8)`. Devinez la valeur que renvoient les expressions logiques suivantes, puis vérifiez-les en créant `f1` et en les évaluant.`r .fun("==")``r .fun("\"!=")``r .fun("<")``r .fun("\"!")``r .fun("\\&")``r .fun("\"|")``r .fun("\\%in\\%")`
    ```{r, eval = FALSE}
f1 == 2
f1 != 7
f1 < 6
f1 != 2
!(f1  == 2)
f1 > 3 & f1 != 5
(f1 < 1 | f1 > 3) & f1 != 8
f1 %in% c(-4, 7)
    ```

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création du vecteur f1
    f1 <- c(5, 2, -4, 8)
    
    # Evaluation des expressions logiques
    f1 == 2
    f1 != 7
    f1 < 6
    f1 != 2
    !(f1  == 2)
    f1 > 3 & f1 != 5
    (f1 < 1 | f1 > 3) & f1 != 8
    f1 %in% c(-4, 7)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. On définit le vecteur `f2 <- rep(c("a","b","a"), times = 10)``r .fun("rep")`. Déterminez automatiquement le nombre d'éléments de `f2` égaux à `"a"` ainsi que leur position`r .fun("[")``r .fun("which")``r .fun("sum")`. Sélectionnez les éléments égaux à `"b"` et remplacez leur valeur par `"c"`. 

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création du vecteur f2
    f2 <- rep(c("a","b","a"), times = 10)
    f2
    
    # Nombre d'éléments égaux à "a"
    sum(f2 == "a")
    
    # Position des éléments égaux à "a"
    which(f2 == "a")
    
    # Sélection des éléments égaux à "b"
    f2[f2 == "b"]
    
    # Remplacement des élements égaux à "b" par "c"
    f2[f2 == "b"] <- "c"
    f2
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

```{r, results = "asis", echo = FALSE}
.souspartie("Manipuler des vecteurs numériques")
```

Plusieurs fonctions sont spécifiquement utilisées pour générer des vecteurs de type numérique :

- `seq()``r .fun("seq", bold = TRUE)` : **`seq()` produit des séquences de nombres**. Dans les cas courants, elle peut être remplacée par `:``r .fun(":", bold = TRUE)` :
    ```{r}
# Création d'un vecteur avec la fonction seq()
seq(1, 20)

# Remplacement par `:`
1:20

# Un cas particulier où seq() ne peut pas directement être remplacé
# par `:`
seq(1, 20, by = 2)
    ```

- les **fonctions `rXXXX` de tirage dans une variable (pseudo-)aléatoire** : R dispose d'un large famille de fonctions tirant de façon pseudo-aléatoire selon une certaine loi (spécifiée par les lettres `XXXX`). **Les plus fréquemment utilisées sont `runif()` (loi uniforme sur [0;1]) et `rnorm()` (loi normale centrée réduite)**`r .fun("runif", bold = TRUE)``r .fun("rnorm", bold = TRUE)` : 
    ```{r}
# Création d'un vecteur de taille 20 avec la fonction runif()
runif(20)

# Création d'un vecteur de taille 20 avec la fonction rnorm()
rnorm(20)
    ```

\ 

Les **opérations arithmétiques** sont appliquées termes à termes sur des vecteurs`r .fun("+")``r .fun("-")``r .fun("*")``r .fun("/")` : 

```{r}
# Génération de deux vecteurs numériques
g1 <- rep(2, times = 10)
g1
g2 <- 1:10
g2

# Application d'opérateurs arithmériques
g1 + g2
g1 - g2
g1 * g2
g1 / g2
```

**Quand les vecteurs ne sont pas de même longueur, les éléments du plus petit des deux sont automatiquement répétés**. Un avertissement apparaît quand la longueur du plus grand vecteur n'est pas un multiple de la longueur du plus petit.
```{r, warnings = TRUE}
g1

# Répétition automatique des éléments du vecteur g3
g3 <- 1:5
g3
g1 + g3

# Répétition automatique des éléments du vecteur g4
g4 <- 1:3
g4
g1 + g4
```

Cette réutilisation des éléments du vecteur permet de très simplement effectuer des **opérations entre un vecteur de taille quelconque et un scalaire** (*i.e.* un vecteur de taille 1).
```{r, warnings = TRUE}
# Opération entre un vecteur et un scalaire
g2 * 3
# La valeur unique du vecteur c(3) est réutilisée
# pour atteindre la longueur de g2 (10). 
```

\ 

Enfin, de nombreuses fonctions peuvent être appliquées à l'**ensemble d'un vecteur de type numérique** (*cf.* tableau).

**Code R** | **Résultat**
----------|---------
`sum(v)``r .fun("sum", bold = TRUE)` | Somme du vecteur `v`
`cumsum(v)``r .fun("cumsum", bold = TRUE)`  | Somme cumulée du vecteur `v`
`mean(v)``r .fun("mean", bold = TRUE)`  | Moyenne du vecteur `v`
`quantile(v)``r .fun("quantile", bold = TRUE)` | Quantiles du vecteur `v`
`summary(v)``r .fun("summary", bold = TRUE)` | Moyenne et quantiles du vecteur `v`
`max(v)``r .fun("max", bold = TRUE)`  | Valeur maximum du vecteur `v`
`min(v)``r .fun("min", bold = TRUE)`  | Valeur minimum du vecteur `v`
`which.min(v)``r .fun("which.min", bold = TRUE)`  | Position du minimum du vecteur `v`
`which.max(v)``r .fun("which.max", bold = TRUE)`  | Position du maximum du vecteur `v`
`round(v, 2)``r .fun("round", bold = TRUE)` | Arrondi du vecteur `v` à deux décimales



```{r,results = "asis", echo = FALSE}
.question("Manipuler des vecteurs numériques")
```

a. Utilisez la fonction `seq()``r .fun("seq")` pour construire la série de nombres de 0 à 10 de 0.5 en 0.5. Comment pourriez-vous y parvenir en utilisant l'opérateur `:``r .fun(":")` ?

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Méthode directe : utilisation de l'argument by = de seq()
    seq(0, 10, by = 0.5)
    
    # Méthode "manuelle" : utilisation de `:` et division
    (0:20) / 2
    
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. Générez un vecteur `h1` de longueur 20 tiré dans une loi uniforme sur [0;1]`r .fun("runif")`. Sélectionnez les éléments de `h1` dont la position est paire selon deux méthodes, l'une utilisant la fonction `seq()``r .fun("seq")` et l'autre la fonction `rep()``r .fun("rep")`.

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création du vecteur h1 avec runif()
    h1 <- runif(20)
    h1
    # Note : la génération de h1 étant aléatoire, il est
    # normal que vous n'obteniez pas exactement les mêmes
    # valeurs. 
    
    # Méthode avec seq() : 
    # 1) construction du vecteur des positions
    seq(2, 20, by = 2)
    # 2) utilisation avec l'opérateur `[`
    h1[seq(2, 20, by = 2)]
    
    # Méthode avec rep() 
    # 1) construction d'un vecteur logique
    rep(c(FALSE, TRUE), times = 10)
    # 2) utilisation avec l'opérateur `[`
    h1[rep(c(FALSE, TRUE), times = 10)]
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. En vous inspirant de la méthode utilisant la fonction `seq()` de la question précédente, construisez la fonction `elementsPairs(x)``r .fun("function")` qui retourne automatiquement les éléments du vecteur `x` dont la position est paire`r .fun("length")`.

    ```{r,results = "asis", echo = FALSE}
    .indic("**Indication** Généralisez la réponse à la question précédente en utilisant notamment la fonction `length()`.")
    ```

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, error = TRUE}
    # Reprise de la méthode avec seq()
    h1[seq(2, 20, by = 2)]
    
    # Difficulté : il faut que la fonction puisse porter
    # sur un vecteur de taille quelconque
    # La taille du vecteur de positions à générer doit
    # donc dépendre de la longueur du vecteur sur lequel
    # porte la fonction. Pour ce faire, on utilise 
    # la fonction length() :
    h1[seq(2, length(h1), by = 2)]
    
    # Définition de la fonction
    elementsPairs <- function(x){
      resultat <- x[seq(2, length(x), by = 2)]
      return(resultat)
    }
    
    # Appel de la fonction elementsPairs()
    elementsPairs(1:10)
    elementsPairs(1:9)
    
    # Note : Ne fonctionne pas avec des vecteurs de longueur 1
    elementsPairs(1)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

d. Créez un vecteur `h2` de longueur 15 et tiré dans une loi normale centrée réduite`r .fun("rnorm")`. Déterminez sa valeur maximale`r .fun("max")``r .fun("which.max")`. En utilisant notamment l'opérateur d'extraction `[`, déterminez alors la deuxième valeur maximale de `h2`.

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Génération du vecteur h2 avec la fonction rnorm()
    h2 <- rnorm(15)
    h2
    # Note : la génération de h2 étant aléatoire, il est
    # normal que vous n'obteniez pas exactement les mêmes
    # valeurs. 
    
    # Utilisation de la fonctions max()
    max(h2)
    
    # Pour déterminez la deuxième valeur maximale de h2,
    # il suffit d'appliquer la fonction max au vecteur
    # h2 privé de sa valeur maximale
    
    # Deux stratégies : 
    
    # 1) utiliser la fonction which.max() pour renvoyer 
    # la position de la valeur maximale de h2 et l'exclure avec -
    which.max(h2)
    h2[-which.max(h2)]
    max(h2[-which.max(h2)])
    
    # 2) utiliser un vecteur logique pour ne sélectionner 
    # que les valeurs strictement inférieures à la valeur 
    # maximale 
    h2 < max(h2)
    h2[h2 < max(h2)]
    max(h2[h2 < max(h2)])
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

```{r, results = "asis", echo = FALSE}
.souspartie("Manipuler des vecteurs caractères")
```

Comme pour les vecteurs de type numérique, il existe dans R des fonctions spécifiquement adaptées pour créer et manipuler des vecteurs de type caractère : 

- `nchar()``r .fun("nchar", bold = TRUE)`, `toupper()``r .fun("toupper", bold = TRUE)`, `tolower()``r .fun("tolower", bold = TRUE)` : **`nchar()` renvoie le nombre de caractères** que représente chaque élément d'un vecteur de type caractère, les fonctions **`tolower()` et `toupper()` convertissent un vecteur caractère en minuscules et majuscules** respectivement.
    ```{r}
# Création du vecteur i1
i1 <- c("aa", "B", "cccc", "DDD")
i1

# Détermination du nombre de caractères avec nchar()
nchar(i1)

# Passage en minuscules ou en majuscules
tolower(i1)
toupper(i1)
    ```

\ 

- `paste()``r .fun("paste", bold = TRUE)`: **`paste()` et sa variante `paste0()` permettent d'agglutiner un ou plusieurs vecteurs caractères**`r .fun("paste0", bold = TRUE)`.
    ```{r}
# Création des vecteurs i2 et i3
i2 <- c("a", "b")
i3 <- c("c", "d")

# Fonctionnement de paste() et paste0()
paste(i2, i3)
paste(i2, i3, sep = "_")
paste0(i2, i3)

# Argument collapse = 
paste(i2, collapse = "*")
paste(i2, i3, sep = "_", collapse = "*")
    ```

\ 

- `formatC``r .fun("formatC", bold = TRUE)`: **`formatC()` convertit un vecteur numérique en vecteur caractère en spécifiant un format**.

    ```{r}
# Utilisation de formatC() pour ajouter des zéros
# devant des chiffres 
formatC(c(1, 2, 56, 789), flag = "0", width = 4)
    ```

\ 

- `letters` et `LETTERS`: `letters` et `LETTERS` sont des objets qui contiennent les 26 lettres de l'alphabet, en minuscules et en majuscules respectivement.

    ```{r}
letters
LETTERS
    ```


```{r,results = "asis", echo = FALSE}
.question("Manipuler des vecteurs caractères : Reconstituer un identifiant de fiche-adresse")
```
L'objectif de ce cas pratique est de **reconstituer un identifiant de fiche-adresse** (utilisé dans les enquêtes auprès des ménages de l'Insee) à partir de **trois informations** : 

- le **numéro de la région de gestion** (`rges`) codé sur **deux positions** ;
- le **numéro de la fiche-adresse** (`numfa`) codé sur **six positions** (avec des 0 devant si nécessaire) ;
- le **numéro de sous-échantillon** (`ssech`) codé sur **deux positions** (avec un 0 devant si nécessaire).

```{r}
rges <- c(11, 11, 21, 21, 22, 31, 74, 81, 81, 94)
numfa <- c(1, 102, 32, 1219, 98, 3, 678, 21, 89, 45)
ssech <- c(1, 11, 1, 1, 1, 2, 2, 2, 12, 11)
```

**L'identifiant de fiche-adresse est défini par la concaténation de `rges`, `numfa` et `ssech`: `rges||numfa||ssech`**. Par exemple, si `rges = 11`, `numfa = 1` et `ssech = 1`, l'identifiant de fiche-adresse est `1100000101` (après ajout de `0` intercalaires).

a. Utilisez la fonction `paste()``r .fun("paste")` pour agglutiner les vecteurs `rges`, `numfa` et `ssech`. Utilisez l'argument `sep = ` pour supprimer le séparateur. Cela produit-il le résultat souhaité ? 

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Utilisation de la fonction paste()
    paste(rges, numfa, ssech)
    
    # Suppression du séparateur
    paste(rges, numfa, ssech, sep = "")
    # Cela ne correspond pas car il manque les 0 devant le numéro 
    # de fiche-adresse et le numéro de sous-échantillon
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. Utilisez la fonction `formatC()``r .fun("formatC")` pour reformater correctement le vecteur `numfa`.  Combinez les fonctions `formatC()` et `paste()``r .fun("paste")` (ou `paste0()``r .fun("paste0")`) et appliquez-les à `numfa` et à `ssech` pour obtenir le résultat souhaité.


    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Utilisation de la fonction formatC()
    formatC(numfa, flag = "0", width = 6)
    
    # Reformatage complet avec paste0()
    paste0(
      formatC(rges, flag = "0", width = 2)
      , formatC(numfa, flag = "0", width = 6)
      , formatC(ssech, flag = "0", width = 2)
    )
    # Cette fois-ci on obtient bien le résultat souhaité.
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. Créez la fonction `creerIdentFA(rges, numfa, ssech)``r .fun("function")` qui produise automatiquement l'identifiant de fiche-adresse. 

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création de la fonction creerIdentFA()
    creerIdentFA <- function(rges, numfa, ssech){
      paste0(
        formatC(rges, flag = "0", width = 2)
        , formatC(numfa, flag = "0", width = 6)
        , formatC(ssech, flag = "0", width = 2)
      )
    }
    creerIdentFA(rges, numfa, ssech)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

```{r, results = "asis", echo = FALSE}
.souspartie("Modifier la structure d'un vecteur")
```

Plusieurs fonctions sont susceptibles d'être appliquées à un vecteur pour modifier ses caractéristiques :

- les **opérations ensemblistes** : fonctions `intersect()``r .fun("intersect", bold = TRUE)` et `setdiff()``r .fun("setdiff", bold = TRUE)`
    ```{r}
# Création des vecteurs k1 et k2
k1 <- letters[1:4]
k2 <- letters[3:6]
k1
k2

# Intersection de k1 et k2
intersect(k1, k2)

# Elements présents dans k1 mais pas dans k2
setdiff(k1, k2)

# Elements présents dans k2 mais pas dans k1
setdiff(k2, k1)
    ```

\ 

- les fonctions de **traitement des doublons** : la fonction `duplicated(x)``r .fun("duplicated", bold = TRUE)` indique si un élément est le doublon d'un élément dont la position est inférieure dans le vecteur `x` (autrement dit qui apparaît précédemment dans le vecteur), la fonction `unique(x)``r .fun("unique", bold = TRUE)` renvoie le vecteur `x` sans doublons. 
    ```{r}
# Création du vecteur k3
k3 <- c(1, 2, 1, 4, 2, 3)
k3
  
# Détection des éléments qui sont des doublons
duplicated(k3)

# Suppression des doublons
unique(k3)
    ```

\ 

- les fonctions de **changement d'ordre** : `rev(x)``r .fun("rev", bold = TRUE)` inverse l'ordre du vecteur `x`, `sort(x)``r .fun("sort", bold = TRUE)` renvoie le vecteur `x` trié et `order(x)``r .fun("order", bold = TRUE)` renvoie la permutation des positions du vecteur `x` nécessaire pour que `x` soit trié

    ```{r}
# Création du vecteur k4
k4 <- c("a", "d", "b", "c")
k4

# Inversion de k4
rev(k4)

# Tri de k4 avec sort()
sort(k4)

# Tri de k4 avec order()
order(k4)
k4[order(k4)]
    ```

    ------------------

    **Remarque** Le tri d'un vecteur avec `order()` est **beaucoup moins intuitif qu'avec `sort()`** et ne présente pas grand intérêt en lui-même. Néanmoins, **seule la méthode avec `order()` est utilisable sur une table de données** (*cf.* `r .ref("module 3", "module3.html")`), aussi autant se familiariser au plus tôt avec sa logique de fonctionnement !

    ------------------



```{r,results = "asis", echo = FALSE}
.question("Modifier la structure d'un vecteur : Travailler avec des identifiants")
```
L'objectif de ce cas pratique est d'utiliser les fonctions présentées dans cette sous-partie pour travailler efficacement avec des identifiants dans R. On définit les deux vecteurs suivants : 
```{r}
# Départements d'Ile-de-France présents dans une enquête
enq <- c("91", "75", "75", "94", "93", "94", "78", "77", "77")

# Liste des départements de la petite couronne
pc <- c("75", "92", "93", "94")
```

a. À l'aide d'opérations ensemblistes, déterminez : 

    i. les départements de la petite couronne présents dans l'enquête`r .fun("intersect")` ;
    ii. les départements de la petite couronne absents de l'enquête`r .fun("setdiff")` ;
    iii. les départements de l'enquête qui ne sont pas dans la petite couronne.

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    enq
    pc
    
    # i.
    intersect(enq, pc)
    # Les départements de la petite couronne présents dans
    # l'enquête sont le 75, le 94 et le 93
    
    # ii.
    setdiff(pc, enq)
    # Le 92 est le seul département de la petite couronne absent de l'enquête
    
    # iii.
    setdiff(enq, pc)
    # Les départements 91, 78 et 77 sont présents dans
    # l'enquête mais ne sont pas de la petite couronne
    
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. Le vecteur `enq` comporte-t-il des valeurs en double ? Répondez en utilisant la fonction `duplicated()``r .fun("duplicated")`. Supprimez les valeurs en double dans `enq` avec `duplicated()` ou `unique()``r .fun("unique")`.

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    enq 
    
    # Que renvoie duplicated(enq) ?
    duplicated(enq)
    # duplicated(enq) renvoie TRUE si la valeur de l'élément
    # est déjà apparue dans le vecteur 
    
    # Pour déterminer si enq comporte ou non des valeurs
    # en double, il suffit de compter le nombre de valeurs
    # vraies de duplicated(enq)
    sum(duplicated(enq))

    # Deux stratégies pour supprimer les doublons : 
    # 1) prendre les valeurs fausses de duplicated(enq)
    enq[!duplicated(enq)]
    # 2) utiliser la fonction unique()
    unique(enq)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. Proposez deux méthodes pour trier le vecteur `enq`, une qui utilise `sort()` et une qui utilise `order()``r .fun("sort")``r .fun("order")`. 


```{r,results = "asis", echo = FALSE}
.beginsol()
```
```{r}
enq

# Méthode directe : Tri avec sort()
sort(enq)

# Méthode indirecte : Obtention de la permutation avec 
# order() puis redéfinition du vecteur
order(enq)
# Ces nombres indiquent la position des éléments de dep
# à utiliser pour obtenir un vecteur trié. 

# Exemple sur les trois premiers éléments :
enq[c(2, 3, 8)]

# Il n'y a donc qu'à utiliser order(enq) avec l'opérateur
# `[` pour obtenir le résultat souhaité
enq[order(enq)]
```
```{r,results = "asis", echo = FALSE}
.endsol()
```

```{r, results = "asis", echo = FALSE}
.partie("Les vecteurs : aspects particuliers")
```

```{r, results = "asis", echo = FALSE}
.souspartie("Savoir traiter les valeurs spéciales")
```

R dispose de plusieurs **valeurs spéciales** qui interviennent dans des situations très différentes : 

- `NA` (pour *Not Available*) correspond à des valeurs manquantes. Il est très fréquent en pratique de rencontrer des valeurs `NA` dans des tableaux de données. À noter que les valeurs manquantes sont toujours indiquées par `NA`, quel que soit le type du vecteur. 
    ```{r}
# Exemple de vecteurs présentant des valeurs NA
l1 <- c(1, 2, 3, NA, 5)
l1
l2 <- c("a", "b", NA, "d")
l2
l3 <- c(NA, NA, TRUE, FALSE)
l3
    ```

\ 

- `Inf` et `-Inf` correspondent à l'infini en positif et en négatif respectivement. 
    ```{r}
# Exemple de situation dans laquelle survient un Inf
5/0
    ```

\ 

- `NaN` (pour `Not a Number`) correspond aux cas dans lesquels un calcul mathématique ne conduit à aucun résultat sensé. 
    ```{r}
# Exemple de situation dans laquelle survient un NaN
0/0
    ```

\ 

Pour identifier (voire supprimer ou remplacer) ces valeurs spéciales, des fonctions spécifiques existent : `is.na()``r .fun("is.na", bold = TRUE)`, `is.infinite()``r .fun("is.infinite", bold = TRUE)`, `is.nan()``r .fun("is.nan", bold = TRUE)`. 
```{r}
# Création du vecteur l4
l4 <- c(1, NA, 3, NaN, 5, Inf)
l4

is.na(l4)
# Remarque : la fonction is.na() identifie à la fois les éléments NA
# et les éléments NaN. 

is.nan(l4)
# Remarque : la fonction is.nan() n'identifie que les éléments NaN
# (pas les éléments NA)

# Pour identifier les éléments NA uniquement (et pas les NaN), il suffit
# de combiner logiquement is.na() et is.nan()
is.na(l4) & !is.nan(l4)

is.infinite(l4)

```

\ 

Ces valeurs **changent le comportement de la plupart des fonctions, notamment les fonctions `sum()`, `table()`**`r .fun("sum")``r .fun("table")`.
```{r}
l1

# En présence d'une ou plusieurs valeurs NA, la fonction sum() 
# renvoie systématiquement NA
sum(l1)

# Pour modifier ce comportement, il suffit d'utiliser l'argument 
# na.rm = TRUE de la fonction sum() (taper ? sum pour plus 
# d'informations).
sum(l1, na.rm = TRUE)

# Par défaut, la fonction table() n'affiche pas les valeurs manquantes
l5 <- c("Femme", NA, "Homme", "Femme", NA, "Femme")
table(l5)

# Utiliser l'argument useNA = "always" permet d'afficher
# toujours le nombre de valeurs NA (y compris quand il n'y
# en a 0).
table(l5, useNA = "always")
```

-------------------

**Remarque importante** En présence d'une valeur `NA`, **l'opérateur `==` renvoie `NA`**`r .fun("==")`. Ce comportement ne correspond pas à celui d'autres logiciels statistiques et peut s'avérer **source d'erreur dans le recodage de variables**. Pour cette raison, on peut lui **préférer systématiquement l'opérateur `%in%`**`r .fun("\\%in\\%")`.

```{r}
l5

# En présence de valeurs NA, == renvoie NA
l5 == "Homme"

# En présence de valeurs NA, %in% renvoie FALSE
l5 %in% "Homme"
```

-------------------


<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .question("(Optionnel) Savoir traiter les valeurs spéciales") -->
<!-- ``` -->

<!-- a. On définit le vecteur `m1 <- c(1, 2, NA, NaN, 5, 6, Inf, 8, 9, NA, NA, -Inf, NaN, 14)`. Comptez le nombre de valeurs `NA` ou `NaN` d'une part, le nombre de valeurs infinies d'autre part`r .fun("is.na")`.  -->

<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .beginsol() -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # Création du vecteur m1 -->
<!-- m1 <- c(1, 2, NA, NaN, 5, 6, Inf, 8, 9, NA, NA, -Inf, NaN, 14) -->
<!-- m1 -->

<!-- # L'idée est la suivante : construire un vecteur -->
<!-- # logique à l'aide des fonctions is.na(), etc. -->
<!-- # puis utiliser la fonction sum() -->
<!-- is.na(m1) -->
<!-- sum(is.na(m1)) -->

<!-- is.infinite(m1) -->
<!-- sum(is.infinite(m1)) -->
<!-- ``` -->
<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .endsol() -->
<!-- ``` -->

<!-- b. Utilisez les éléments de la question précédente pour supprimer toutes les valeurs spéciales du vecteur `m1``r .fun("is.na")``r .fun("is.infinite")`. -->

<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .beginsol() -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # On repart des mêmes éléments qu'à la question -->
<!-- # précédente, mais cette fois-ci les vecteurs  -->
<!-- # logiques sont utilisés pour extraire des éléments -->
<!-- # du vecteur x -->
<!-- !is.na(m1) -->
<!-- m1[!is.na(m1)] -->

<!-- !is.infinite(m1) -->
<!-- m1[!is.infinite(m1)] -->

<!-- # On n'a qu'à combiner les deux expressions pour  -->
<!-- # obtenir le résultat souhaité -->
<!-- m1[!is.na(m1) & !is.infinite(m1) ] -->
<!-- ``` -->
<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .endsol() -->
<!-- ``` -->

```{r, results = "asis", echo = FALSE}
.souspartie("Conversion de type et type facteur")
```

On a vu que quand c'est nécessaire, R modifie le type d'un vecteur pour s'adapter à de nouvelles données. 
```{r}
# Création du vecteur logique n1
n1 <- c(FALSE, TRUE, FALSE)

# Conversion en cas de concaténation avec un vecteur 
# de type numérique
c(n1, 3)

# Conversion en cas de concaténation avec un vecteur 
# de type caractère
c(n1, "a")
```

Mais il est aussi parfois très utile de **convertir explicitement des vecteurs d'un type dans un autre**, grâce aux fonctions `as.numeric()``r .fun("as.numeric", bold = TRUE)`, `as.character()``r .fun("as.character", bold = TRUE)` et `as.logical()``r .fun("as.logical", bold = TRUE)`. 
```{r}
# Âge codé en caractères
age <- c("56", "14", "78")
as.numeric(age)

# Indicatrice codée en numérique
indic <- c(1, 0, 0, 1, 0)
as.logical(indic)
```

Ces opérations peuvent néanmoins produire des `NA`, en particulier quand un vecteur caractère est converti en vecteur numérique. 
```{r, warning = TRUE}
# Conversion du département en numérique
dep <- c("75", "92", "93", "13", "2A", "2B")
as.numeric(dep)
```

\ 

D'autre part, le type "facteur" est un type de vecteur particulier, **à mi-chemin entre le vecteur caractère et le vecteur numérique** : 

- les valeurs stockées par R sont des entiers ;
- MAIS à chaque entier est associé un "label" permettant d'**afficher une chaîne de caractère à la place du nombre correspondant**. 

Les objets de type facteur sont créés le plus souvent avec la **fonction `factor()`**`r .fun("factor", bold = TRUE)`.
```{r}
# Création du vecteur de type factor n2
n2 <- factor(c("banane", "pomme", "poire", "banane", "banane"))
n2

# Caractéristiques de n2
str(n2)
```

La fonction `str()` révèle que les valeurs stockées sont `r as.integer(n2)`, valeurs qui sont "formatées"" par le biais des "labels" (`levels`) `r levels(n2)``r .fun("levels", bold = TRUE)`. 

------------

**Remarque** On retrouve en fait exactement la **même logique que le formatage de variable dans SAS ou l'utilisation de labels de variables dans Stata**. 

------------

Quand une variable de type caractère comporte un nombre limité de modalités distinctes, le type facteur peut induire d'**importants gains de performance** : il est en effet **plus efficace de stocker et de manipuler des nombres entiers que des chaînes de caractère parfois longues**. 

R étant un logiciel à l'origine pensé pour la statistique mathématique où les variables proprement caractère sont peu nombreuses, **la plupart des fonctions de base proposent par défaut de convertir les variables de type caractère en variables de type facteur**. C'est notamment le cas des **fonctions d'importation standards** (`read.table()``r .fun("read.table")`, `read.dbf()``r .fun("read.dbf")`) mais aussi de la fonction de construction des objets de type **`data.frame`** (*cf.* `r .ref("module 3", "module3.html")`). 


```{r, results = "asis", echo = FALSE}
.partie("Les matrices : création et sélection")
```

**Les matrices peuvent être vues comme le prolongement en deux dimensions des vecteurs** : si ce n'est l'existence de deux jeux de positions au lieu d'un seul et de quelques fonctions spécifiques, leurs principes d'utilisation sont les mêmes.

**Le type d'objet utilisé pour stocker des données statistiques, le `data.frame` (*cf.* `r .ref("module 3", "module3.html")`) présente des points communs avec les matrices (accès aux objets par deux positions, utilisation de fonctions adaptées aux objets en deux dimensions, etc.).** 

La **fonction `matrix()`**`r .fun("matrix", bold = TRUE)` est la manière la plus simple de créer des matrices. 
```{r}
matrix(1:8, nrow = 2, ncol = 4)
```
R utilise les valeurs du premier argument (un vecteur de données) pour remplir la matrice dont les dimensions sont indiquées par les arguments `nrow` (nombre de lignes) et `ncol` (nombre de colonnes). 

Par défaut, **R remplit la matrice colonne par colonne** : d'abord la première colonne de haut en bas, puis la deuxième de haut en bas, etc. L'argument `byrow` (`FALSE` par défaut) permet de remplir la matrice ligne par ligne. 
```{r}
matrix(1:8, nrow = 2, ncol = 4, byrow = TRUE)
```

Comme un vecteur, **une matrice a un type** (fonction `mode()``r .fun("mode")`). Sa longueur (fonction `length()``r .fun("length")`) correspond à la longueur de son vecteur de données. Ses dimensions sont accessibles *via* les fonctions `dim()``r .fun("dim", bold = TRUE)`, `nrow()``r .fun("nrow", bold = TRUE)` et `ncol()``r .fun("ncol", bold = TRUE)`. 
```{r}
# Création de la matrice o1
o1 <- matrix(letters[1:15], nrow = 3, ncol = 5)
o1

# Caractéristiques de o1
str(o1)
mode(o1)
length(o1)
dim(o1)
nrow(o1)
ncol(o1)
```

On peut toujours à partir d'une matrice **revenir au vecteur de données** en utilisant les fonctions `c()``r .fun("c")` ou `as.vector()``r .fun("as.vector")`. 
```{r}
# Reconstitution du vecteur de données de 
# la matrice o1
c(o1)
as.vector(o1)
```

\ 

Pour sélectionner un élément dans une matrice, il suffit d'**utiliser l'opérateur `[` avec deux nombres correspondant à la position de l'élément séparés par une virgule**`r .fun("[", bold = TRUE)` : 
```{r}
o1

# Sélection de l'élément en ligne 2 et colonne 3
o1[2, 3]
# Note : Le premier nombre correspond à la ligne,
# le second à la colonne
```

Pour sélectionner **une ligne ou une colonne entière**, il suffit de n'indiquer qu'un seul nombre mais bien **toujours la virgule `,`**. 
```{r}
o1

# Sélection de toute la première ligne
o1[1, ]

# Sélection de toute la cinquième colonne
o1[, 5]
```

Il est également possible de **sélectionner les lignes et les colonnes d'une matrice par le biais de vecteurs logiques**.
```{r}
o1

# Sélection de toute la deuxième ligne
o1[c(FALSE, TRUE, FALSE), ]

# Sélection des colonnes 2 et 4
o1[, c(FALSE, TRUE, FALSE, TRUE, FALSE)]
```

\ 

Comme pour les vecteurs, il est également **possible d'assigner des noms à une matrice à l'aide des fonctions `rownames()` et `colnames()`**`r .fun("rownames", bold = TRUE)``r .fun("colnames", bold = TRUE)`. Quand une matrice dispose de noms, ils peuvent être **utilisés en lieu et place des positions de ligne et de colonne**.
```{r}
# Ajout de noms de lignes à o1
rownames(o1) <- c("pierre", "feuille", "ciseaux")
colnames(o1) <- c("pouce", "index", "majeur", "annulaire", "auriculaire")
o1

# Sélection d'éléments par le nom
o1["pierre", "index"]
o1["feuille", ]
o1[, "annulaire"]
```

\ 

-----------------

**À retenir** Comme pour les vecteurs, il existe donc **trois méthodes pour sélectionner des lignes ou des colonnes** dans une matrice *via* l'opérateur `[``r .fun("[")`: 

- utiliser un **vecteur de positions**;
- utiliser un **vecteur de noms** (quand des noms sont définis);
- utiliser un **vecteur logique**.

```{r}
o1

# On cherche à sélectionner la première et de la troisième ligne de o1

# Méthode 1 : par les positions
o1[c(1, 3), ]

# Méthode 2 : par les noms
o1[c("pierre", "ciseaux"), ]

# Méthode 3 : avec un vecteur logique
o1[c(TRUE, FALSE, TRUE), ]

# Remarque : dans les trois cas, on extrait des lignes sans
# toucher aux colonnes donc on laisse une position vide après
# la virgule dans [, ]
```

**Les deux premières méthodes permettent de modifier l'ordre des éléments ou de les répéter, mais pas la troisième** : 

```{r}
o1

o1[c(3, 1, 1, 3), ]


o1[c("ciseaux", "pierre", "pierre", "ciseaux"), ]

o1[c(TRUE, FALSE, TRUE), ]
# Note : il est impossible de changer l'ordre dans lequel apparaissent
# les éléments extraits (ni de les répéter) quand on utilise un vecteur
# logique pour mener l'extraction.
```

Ces différentes méthodes sont **particulièrement utiles en pratique** (*cf.* `r .ref("module 3", "module3.html")`): 

- l'extraction par les positions est à la base des **tris sur une table de données** ;
- l'extraction avec un vecteur logique est à la base de la **sélection d'observations ou de variables dans une table de données**.

---------

\ 


```{r,results = "asis", echo = FALSE}
.question("Créer et sélectionner les éléments d'une matrice")
```

a. Déterminez la valeur, le type et les dimensions des matrices suivantes (sans utiliser le logiciel). Vérifiez ensuite ce qu'il en est.`r .fun("matrix")`
    ```{r}
p1 <- matrix(1:10, ncol = 2)
p2 <- matrix(1:10, nrow = 2, byrow = TRUE)
p3 <- matrix(rep(c(TRUE, 1, "a"), times = 5), nrow = 3)
p4 <- matrix(rep(c(TRUE, 1, "a"), each = 5), nrow = 3)
    ```

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Matrice p1
    p1
    mode(p1)
    dim(p1)
    nrow(p1)
    ncol(p1)
    
    # Matrice p2
    p2
    mode(p2)
    dim(p2)
    nrow(p2)
    ncol(p2)

    # Matrice p3
    p3
    mode(p3)
    dim(p3)
    nrow(p3)
    ncol(p3)

    # Matrice p4
    p4
    mode(p4)
    dim(p4)
    nrow(p4)
    ncol(p4)
    
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```


b. On définit la matrice `p5 <- matrix(15:1, nrow = 3)`. Sélectionnez l'élément en position 1, 4, puis toute la troisième ligne et toute la deuxième colonne`r .fun("[")`. Que se passe-t-il quand vous tapez `p5[c(1, 2), c(3, 4)]` ?

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création de p5
    p5 <- matrix(15:1, nrow = 3)
    p5
    
    # Sélection des éléments demandés
    p5[1, 4]
    p5[3, ]
    p5[, 2]
    
    p5[c(1, 2), c(3, 4)]
    # Taper p5[c(1, 2), c(3, 4)] permet de sélectionner
    # une sous-matrice définie par les lignes 1 et 2
    # d'une part et les colonnes 3 et 4 d'autre part.
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. Assignez les noms `c("Jacques", "Pierre", "Paul")` et `c("orange", "pomme", "poire", "banane", "abricot")` aux lignes et aux colonnes de `p5` respectivement`r .fun("[")`. Que vaut la valeur au croisement de `Pierre` et de `pomme` ? 

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Création de p5
    rownames(p5) <- c("Jacques", "Pierre", "Paul")
    colnames(p5) <- c("orange", "pomme", "poire", "banane", "abricot")
    p5
    
    # Sélection des éléments demandés
    p5["Pierre", "pomme"]
    
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

d. (Difficile) Utilisez la fonction `order()``r .fun("order")` pour trier la matrice `p5` selon les valeurs de sa première colonne pour obtenir : 
    ```{r, echo = FALSE}
p5[order(p5[, 1]), ]
    ```

    ```{r,results = "asis", echo = FALSE}
    .indic("**Indication** Que vaut `p5[c(3, 2, 1), ]` ? Comment utiliser la fonction `order()` pour automatiser cette opération ?")
    ```
    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    p5
    
    # L'idée de base est que l'opérateur [ appliqué à une matrice
    # permet non seulement de sélectionner des lignes ou des colonnes
    # mais aussi de les réarranger comme on le souhaite.
    
    # Par exemple, en tapant p5[c(2, 1, 3), ] on indique vouloir
    # obtenir une matrice : 
    # - dont la première ligne est la deuxième ligne de p5
    # - dont la deuxième ligne est la première ligne de p5
    # - dont la troisième ligne est la troisième ligne de p5
    p5[c(2, 1, 3), ]
    
    # Qu'en est-il de p5[c(3, 2, 1), ] ? 
    p5[c(3, 2, 1), ]
    
    # p5[c(3, 2, 1), ] retourne le résultat désiré car la permutation
    # c(3, 2, 1) est celle qui permet de réordonner la première colonne
    # de p5
    col1 <- p5[, 1]
    col1
    col1[c(3, 2, 1)]
    
    # Pour totalement automatiser cette opération, il ne reste plus
    # qu'à déterminer automatiquement la bonne permutation pour 
    # effectuer le tri souhaité. C'est précisément ce que fait
    # la fonction order() : 
    order(col1)
    col1[order(col1)]
    
    # En combinant l'ensemble de ces éléments, on obtient donc
    # automatiquement le résultat souhaité : 
    p5[order(p5[, 1]), ]
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```


<!-- ```{r, results = "asis", echo = FALSE} -->
<!-- .souspartie("(Optionnel) Effectuer des opérations sur les matrices") -->
<!-- ``` -->

<!-- La plupart des opérations applicables à des vecteurs le sont également à des matrices, en particulier l'ensemble des **opérateurs arithmétiques ou logiques**`r .fun("+")``r .fun("<=")`. -->
<!-- ```{r} -->
<!-- q1 <- matrix(1:10, nrow = 2) -->
<!-- q1 -->
<!-- q2 <- matrix(2, nrow = 2, ncol = 5) -->
<!-- q2 -->

<!-- # Opérations arithmétiques ou logiques -->
<!-- q1 + q2 -->
<!-- q1 <= 3 -->
<!-- ``` -->

<!-- Certaines opérations sont néanmoins spécifiques aux matrices :  -->

<!-- - les fonctions de **concaténation par ligne (`rbind()`) et par colonne (`cbind()`)**`r .fun("rbind", bold = TRUE)``r .fun("cbind", bold = TRUE)` -->
<!--     ```{r} -->
<!-- q3 <- matrix(1:10, nrow = 2) -->
<!-- q3 -->
<!-- q4 <- matrix(letters[1:10], nrow = 2) -->
<!-- q4 -->

<!-- # Concaténation par ligne -->
<!-- rbind(q3, q4) -->

<!-- # Concaténation par colonne -->
<!-- cbind(q3, q4) -->
<!--     ``` -->

<!-- - les fonctions liées au **calcul matriciel** : transposition (fonction `t()``r .fun("t", bold = TRUE)`), produit matriciel (opérateur `%*%``r .fun("\\%*\\%", bold = TRUE)`), calcul de déterminant (fonction `det()``r .fun("det", bold = TRUE)`), inversion de matrice (fonction `solve()``r .fun("solve", bold = TRUE)`). -->
<!--     ```{r} -->
<!-- q5 <- matrix(rnorm(6), nrow = 2) -->
<!-- q5 -->
<!-- q6 <- matrix(rnorm(6), nrow = 2) -->
<!-- q6 -->

<!-- # Calcul matriciel sur q5 et t(q6) -->
<!-- t(q6) -->
<!-- q5 %*% t(q6) -->
<!--     ``` -->


<!-- - certaines **fonctions d'agrégation** adaptées au cadre matriciel : somme et moyenne selon les lignes (`rowSums()``r .fun("rowSums", bold = TRUE)` et `rowMeans()``r .fun("rowMeans", bold = TRUE)`) ou selon les colonnes (`colSums()``r .fun("colSums", bold = TRUE)` et `colMeans()``r .fun("colMeans", bold = TRUE)`). -->
<!--     ```{r} -->
<!-- q7 <- matrix(1:10, nrow = 2) -->
<!-- q7 -->

<!-- # Calcul selon les lignes et les colonnes de q7 -->
<!-- rowSums(q7) -->
<!-- rowMeans(q7) -->
<!-- colSums(q7) -->
<!-- colMeans(q7) -->
<!--     ``` -->

<!-- - **la fonction `apply()` pour appliquer n'importe quelle fonction selon les lignes ou les colonnes d'une matrice**`r .fun("apply", bold = TRUE)` -->
<!--     ```{r} -->
<!-- q7 -->

<!-- # Récupération du maximum de q7 ligne par ligne -->
<!-- apply(q7, 1, max) -->

<!-- # Récupération du maximum de q7 colonne par colonne -->
<!-- apply(q7, 2, max) -->

<!-- # Note : le deuxième argument de apply() correspond  -->
<!-- # à la dimension selon laquelle on applique la fonction :  -->
<!-- # 1 pour les lignes, 2 pour les colonnes. -->
<!--     ``` -->


<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .question("(Optionnel) Effectuer des opérations sur les matrices") -->
<!-- ``` -->

<!-- a. On définit la matrice `r1 <- matrix((1:15)^2, ncol = 5, byrow = TRUE)`. -->

<!--     i. Déterminez le nombre d'éléments supérieurs ou égaux à 60 dans l'ensemble de la matrice, puis dans chaque ligne et dans chaque colonne.`r .fun("sum")``r .fun("rowSums")``r .fun("colSums")` -->

<!--         ```{r,results = "asis", echo = FALSE} -->
<!--         .beginsol() -->
<!--         ``` -->
<!--         ```{r} -->
<!--         r1 <- matrix((1:15)^2, ncol = 5, byrow = TRUE) -->
<!--         r1 -->

<!--         # Le point de départ est l'évaluation de l'expression -->
<!--         r1 >= 60 -->

<!--         # On obtient ainsi une matrice de type logique susceptible -->
<!--         # d'être utilisée dans des fonctions d'agrégation -->
<!--         is.logical(r1 >= 60) -->

<!--         # Nombre d'éléments supérieurs ou égaux à 60 dans l'ensemble -->
<!--         # de la matrice -->
<!--         sum(r1 >= 60) -->

<!--         # Nombre d'éléments supérieurs ou égaux à 60 par ligne -->
<!--         rowSums(r1 >= 60) -->

<!--         # Nombre d'éléments supérieurs ou égaux à 60 par colonne -->
<!--         colSums(r1 >= 60) -->
<!--         ``` -->
<!--         ```{r,results = "asis", echo = FALSE} -->
<!--         .endsol() -->
<!--         ``` -->



<!--     ii. Sélectionnez la sous-matrice des colonnes dont le total est strictement supérieur à 200.`r .fun("colSums")` -->

<!--         ```{r,results = "asis", echo = FALSE} -->
<!--         .beginsol() -->
<!--         ``` -->
<!--         ```{r} -->
<!--         # Pour construire la sous-matrice des colonnes -->
<!--         # dont le total est supérieur à 200, on commence -->
<!--         # par calculer le total selon les colonnes -->
<!--         colSums(r1) -->

<!--         # On peut dès lors évaluer l'expression correspondante -->
<!--         colSums(r1) > 200 -->

<!--         # Il ne reste plus qu'à utiliser l'opérateur [ -->
<!--         # pour sélectionner les colonnes à l'aide du vecteur -->
<!--         # logique ainsi créé -->
<!--         r1[, colSums(r1) > 200] -->
<!--         ``` -->
<!--         ```{r,results = "asis", echo = FALSE} -->
<!--         .endsol() -->
<!--         ``` -->

<!-- b. On définit les matrices `r2 <- matrix(rep("a", times = 6), ncol = 2)` et `r3 <- matrix(rep("b", times = 6), nrow = 2)`. Tentez de les concaténer par les lignes et les colonnes`r .fun("rbind")``r .fun("cbind")`. Que se passe-t-il ? Tentez alors de concaténer `r2` et la transposée de `r3``r .fun("t")`. -->

<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .beginsol() -->
<!--     ``` -->
<!--     ```{r, error = TRUE} -->
<!--     r2 <- matrix(rep("a", times = 6), ncol = 2) -->
<!--     r2 -->
<!--     r3 <- matrix(rep("b", times = 6), nrow = 2) -->
<!--     r3 -->

<!--     # Tentative de concaténation par les lignes -->
<!--     rbind(r2, r3) -->

<!--     # Tentative de concaténation par les colonnes -->
<!--     cbind(r2, r3) -->

<!--     # Le problème vient du fait que les dimensions des  -->
<!--     # matrices r2 et r3 ne correspondent pas.  -->

<!--     # En revanche, cela devrait mieux fonctionner avec  -->
<!--     # la transposée de r3 -->
<!--     t(r3) -->
<!--     rbind(r2, t(r3)) -->
<!--     cbind(r2, t(r3)) -->
<!--     ``` -->
<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .endsol() -->
<!--     ``` -->

<!-- c. On définit la matrice `r4 <- matrix(rnorm(8), nrow = 2)`. Utilisez la fonction `apply()``r .fun("apply")` pour calculer l'écart-type de `r4` (fonction `sd()``r .fun("sd", bold = TRUE)`) ligne par ligne puis colonne par colonne.  -->


<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .beginsol() -->
<!--     ``` -->
<!--     ```{r, error = TRUE} -->
<!--     r4 <- matrix(rnorm(8), nrow = 2) -->
<!--     r4 -->

<!--     # Le principe de la fonction apply() est d'appliquer -->
<!--     # une certaine fonction "le long" d'une dimension d'une matrice -->
<!--     # (ligne ou colonne -->

<!--     # Appliquer la fonction sd à la matrice r4 ligne par ligne -->
<!--     apply(r4, 1, sd) -->

<!--     # Appliquer la fonction sd à la matrice r4 colonne par colonne -->
<!--     apply(r4, 2, sd) -->

<!--     # Note : le deuxième argument de apply() correspond  -->
<!--     # à la dimension selon laquelle on applique la fonction :  -->
<!--     # 1 pour les lignes, 2 pour les colonnes. -->
<!--     ``` -->
<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .endsol() -->
<!--     ``` -->


<!-- d. (Optionnel) On définit la matrice `r5 <- matrix(c("aaaa", "bb", "ccc", "d", "eee", "f"), ncol = 2)`. Utilisez la fonction `apply``r .fun("apply")`  pour calculer le nombre maximum de caractère de `r5` ligne par ligne puis colonne par colonne`r .fun("nchar")``r .fun("max")`.  -->

<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .indic("**Indication** Créez la fonction `maxnchar()` qui renvoie, pour un vecteur caractère donné, la longueur en nombre de caractères de son élément le plus long. Utilisez ensuite cette fonction avec `apply()` pour obtenir le résultat attendu.") -->
<!--     ``` -->


<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .beginsol() -->
<!--     ``` -->
<!--     ```{r, error = TRUE} -->
<!--     r5 <- matrix(c("aaaa", "bb", "ccc", "d", "eee", "f"), ncol = 2) -->
<!--     r5 -->

<!--     # On est exactement dans le même cas que précédemment,  -->
<!--     # sinon qu'il n'existe aucune fonction qui calcule  -->
<!--     # directement le nombre maximal de caracères d'un vecteur -->
<!--     # de type caractère.  -->

<!--     # Ce n'est pas réellement une difficulté, dans la mesure -->
<!--     # où il est très facile dans R de créer ses propres fonctions. -->
<!--     # Ici la fonction maxnchar(x) est créée pour renvoyer -->
<!--     # automatiquement le nombre maximal de caractères d'un -->
<!--     # vecteur de type caractère. -->
<!--     maxnchar <- function(x) max(nchar(x)) -->
<!--     maxnchar(c("a", "bb", "ccc", "dddd")) -->

<!--     # On peut manuellement appliquer maxnchar() à la première -->
<!--     # ligne ou à la première colonne de r5 -->
<!--     maxnchar(r5[1, ]) -->
<!--     maxnchar(r5[, 1]) -->

<!--     # Pour l'appliquer automatiquement ligne par ligne ou colonne -->
<!--     # par colonne, il ne reste plus qu'à l'utiliser dans apply() -->
<!--     apply(r5, 1, maxnchar) -->
<!--     apply(r5, 2, maxnchar) -->

<!--     # Remarque 1 : en fait il n'est pas absolument indispensable -->
<!--     # de donner un nom à la fonction maxnchar().  -->
<!--     # On peut également la définir à la volée puis l'utiliser  -->
<!--     # immédiatement dans le apply() :  -->
<!--     apply(r5, 2, function(x) max(nchar(x))) -->

<!--     # Remarque 2 : une méthode (plus simple) consisterait également à  -->
<!--     # appliquer la fonction max() à une transformation de la table r5 -->
<!--     apply(nchar(r5), 1, max) -->
<!--     apply(nchar(r5), 2, max) -->
<!--     ``` -->
<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .endsol() -->
<!--     ``` -->



```{r, results = "asis", echo = FALSE}
.partie("Les listes : création et sélection")
```

Du point de vue de la statistique appliquée, la principale limitation des matrices est qu'elles ne peuvent, comme les vecteurs, contenir qu'un seul type de données. **Il est impossible de construire une matrice dont certaines variables sont de type numérique** (par exemple l'âge des personnes enquêtées) **et d'autres de type caractère** (par exemple leur secteur d'activité). Les matrices ne constituent donc pas un type d'objet susceptible de stocker l'information statistique habituellement mobilisée dans les enquêtes sociales. 

Les **listes** constituent en revanche un type d'objet beaucoup plus riche qui permet précisément de rassembler des types d'objets très différents : **une liste peut contenir tous les types d'objet (vecteurs numériques, caractères, logiques, matrices, etc.), y compris d'autres listes**. Cette très grande souplesse fait de la liste l'objet de prédilection pour **stocker une information complexe et structurée**, en particulier les **résultats de procédures statistiques complexes** (régression, classification, etc.).

Plus encore, le type d'objet utilisé pour stocker des données statistiques, le `data.frame` (*cf.* `r .ref("module 3", "module3.html")`), est un **cas particulier de liste**. La connaissance et la compréhension du fonctionnement des listes dans R **facilite ainsi considérablement le travail sur des données statistiques**.

\ 

La **fonction `list()`**`r .fun("list", bold = TRUE)` crée une nouvelle liste.
```{r}
s1 <- list(
  1:4
  , c("a","b","c")
  , TRUE
  , matrix(rnorm(4), ncol = 2)
)
s1
```

**L'affichage d'une liste diffère sensiblement de celui d'une matrice ou d'un vecteur** : on distingue **deux niveaux de positions**, d'abord celles indiquées entre double-crochets `[[` puis celle indiquées entre crochets simples `[`. 

Comme un vecteur, **une liste a une longueur qui correspond à son nombre d'éléments** au sens du nombre d'éléments intervenant dans la fonction `list()` (positions en double-crochets `[[`). Quand on affiche sa structure, R affiche également celle des éléments qui composent la liste. 
```{r}
# Caractéristiques de s1
length(s1)
str(s1)
```

On constate ici que **la liste `s1` comporte des éléments de type très différents**\ : un vecteur de nombres entiers, un vecteur caractère, un vecteur logique et même une matrice numérique. 

Comme pour les vecteurs, il est possible de **nommer les éléments d'une liste**, soit lors de sa création soit en utilisant la fonction `names()``r .fun("names")`. 
```{r}
 # Affichage des noms de s1
names(s1)

# Ajout de noms à s1
names(s1) <- c("chat", "chien", "lapin", "poisson rouge")
s1
str(s1)

# Définition directe d'une liste nommée
s2 <- list(
  "pierre" = 1:3
  , "feuille" = FALSE
  , "ciseaux" = letters[1:3]
)
s2
```

\ 

Plusieurs opérateurs permettent d'**accéder aux éléments d'une liste** : 

- **`[` renvoie la *sous-liste* correspondant aux indices, noms ou positions logiques demandés**`r .fun("[", bold = TRUE)` ;
    ```{r}
str(s1)
    
 # Utilisation de [
s1[1]

str(s1[1])

s1[c(2, 3)]

s1[-4]

s1[c("lapin", "chien")]

s1[c(TRUE, FALSE, FALSE, TRUE)]
    ```

- **`[[` renvoie l'*élément* correspondant à l'indice ou au nom demandé** (un seul indice ou un seul nom autorisé dans ce cas)`r .fun("[[", bold = TRUE)` ;
    ```{r, error = TRUE}
str(s1)
    
# Utilisation de [[
s1[[1]]

str(s1[[1]])

# Remarque : bien noter la différence avec s1[1]
str(s1[1])
# s1[1] renvoie une sous-liste, quand s1[[1]] renvoie
# l'élément lui-même (ici un vecteur d'entiers)

s1[[c(2, 4)]]
# Note : [[ ne permet de sélectionner qu'un seul élément
# à la fois.

s1[["lapin"]]
    ```

- **`$` renvoie l'élément correspondant au nom demandé** (ne fonctionne qu'avec des listes nommées)`r .fun("\\$", bold = TRUE)`.
    ```{r}
str(s1)
    
# Utilisation de $
s1$chat

str(s1$chat)
    ```

**Pour effectuer des opérations sur un élément d'une liste, il suffit de le sélectionner avec `[[` ou `$`**. 
```{r}
str(s1)

# Opérations sur le premier élément de s1
s1[[1]]
sum(s1[[1]])
mean(s1$chat)
```


```{r,results = "asis", echo = FALSE}
.question("Créer et sélectionner les éléments d'une liste")
```

a. Devinez les valeurs, la longueur et la structure des trois listes suivantes, puis vérifiez-les dans le logiciel.`r .fun("list")`
    ```{r}
t1 <- list("a", "b", 3, "d")
t2 <- list(c("a", "b", 3, "d"))
t3 <- list(list("a", "b"), 3, "d")
    ```

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # t1 est une liste de longueur 4
    str(t1)
    # Chaque élément de t1 est un vecteur de longueur 1
    
    # t2 est une liste de longueur 1
    str(t2)
    # L'élément de t2 est un vecteur caractère de longueur 4
    
    # t3 est une liste de longueur 3
    str(t3)
    # Le premier élément de t3 est une liste (comptant
    # elle-même deux éléments, deux vecteurs caractères)
    # le deuxième est un vecteur numérique et le troisième
    # un vecteur caractère.
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

b. On définit les objets suivants `t4 <- rep(1:3, each = 4)`, `t5 <- letters[c(5, 2, 3)]` et `t6 <- c(TRUE, FALSE, FALSE)`. Créez la liste `t7` à partir de ces trois objets (dans l'ordre) et affectez lui les noms `"Athos"`, `"Porthos"` et `"Aramis"`. Proposez trois méthodes pour accéder au deuxième élément de `t7`.`r .fun("rep")``r .fun("[")``r .fun("[[")``r .fun("\\$")`

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, error=TRUE}
    # Création des objets t4, t5 et t6
    t4 <- rep(1:3, each = 4)
    t4
    t5 <- letters[c(5, 2, 3)]
    t5
    t6 <- c(TRUE, FALSE, FALSE)
    t6
    
    # Création de la liste t4 nommée
    t7 <- list("Athos" = t4, "Porthos" = t5, "Aramis" = t6)
    t7
    
    # Accéder à l'élément en deuxième position
    # - Méthode 1 : [[ avec la position
    t7[[2]]
    # - Méthode 2 : [[ avec le nom
    t7[["Porhos"]]
    # - Méthode 3 : $ avec le nom
    t7$t5
    
    # Remarque : on ne peut pas utiliser de vecteur logique
    # avec [[ ou $
    t7[[c(FALSE, TRUE, FALSE)]]
    # C'est possible en revanche avec [, mais l'objet retourné 
    # n'est pas exactement le même : 
    t7[c(FALSE, TRUE, FALSE)]
    
    str(t7[c(FALSE, TRUE, FALSE)])
    str(t7[["Porhos"]])
    # Avec [ l'objet retourné est toujours une liste (la sous-liste
    # correspondant aux positions, noms ou valeurs TRUE du vecteur
    # logique utilisés) alors qu'avec [[ il s'agit de l'élément lui-même
    # (ici un vecteur de type caractère).
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```

c. On définit la liste `t8 <- list(matrix(1:6, nrow = 2), matrix(letters[1:6], ncol = 2))`. Quelles sont les dimensions de chaque élément de la liste`r .fun("dim")` ? Combien le premier élément de la liste comporte-t-il de valeurs strictement supérieures à 1,8`r .fun("sum")` ?

    ```{r,results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Définition de la liste t8
    t8 <- list(matrix(1:6, nrow = 2), matrix(letters[1:6], ncol = 2))
    t8
    str(t8)
    
    # Dimensions des éléments de t8
    dim(t8[[1]])
    dim(t8[[2]])
    
    # Evaluation d'une clause logique et agrégation
    # sur le premier élément de la liste t8
    t8[[1]]
    t8[[1]] > 1.8
    sum(t8[[1]] > 1.8)
    ```
    ```{r,results = "asis", echo = FALSE}
    .endsol()
    ```


<!-- d. On définit la liste `t9 <- list(t7, t8)`. Quelle est la nature des éléments de la liste `t9` ? Combien d'éléments le premier élément de `t9` comporte-t-il ? Comment accédriez-vous au premier élément du deuxième élément de `t9` ? -->

<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .beginsol() -->
<!--     ``` -->
<!--     ```{r} -->
<!--     # Définition de la liste t9 -->
<!--     t9 <- list(t7, t8) -->
<!--     t9 -->
<!--     str(t9) -->
<!--     # Note : t9 est une liste emboîtée. t9 contient deux listes,  -->
<!--     # qui elles-mêmes contiennent d'autres éléments (trois  -->
<!--     # vecteurs pour la première, deux matrices pour la seconde). -->
<!--     str(t9[[1]]) -->
<!--     str(t9[[2]]) -->

<!--     # Nombre d'élément du premier élément de t9 -->
<!--     length(t9[[1]]) -->

<!--     # Accès au premier élément du deuxième élément de t9 -->
<!--     t9[[2]][[1]] -->
<!--     ``` -->
<!--     ```{r,results = "asis", echo = FALSE} -->
<!--     .endsol() -->
<!--     ``` -->


```{r, results = "asis", echo = FALSE}
.partie("Les listes : opérations")
```

Comme pour les vecteurs, il est possible de manipuler des listes en utilisant la fonction `c()``r .fun("c")` et les **opérations ensemblistes** (fonctions `intersect()``r .fun("intersect")` et `setdiff()``r .fun("setdiff")`).
```{r}
# Création de u1 et u2
u1 <- list(1:5, c("a", "b", "c"))
u1
u2 <- list(1:5, c(FALSE, TRUE, FALSE))
u2

# Concaténation de listes avec c()
c(u1, u2)

# Opérations ensemblistes sur des listes
intersect(u1, u2)
setdiff(u1, u2)
setdiff(u2, u1)
```

\ 

D'autre part, la **fonction `lapply()`** permet d'**appliquer la même fonction à chaque élément d'une liste**`r .fun("lapply", bold = TRUE)`. 
```{r}
# Création de la liste u3
u3 <- list(1:5, 6:10, 11:15)
u3

# Somme de chaque élément de la liste
lapply(u3, sum)
# Note : le premier argument de lapply() la liste
# sur les éléments de laquelle on souhaite appliquer
# une fonction et le second la fonction en question.

# Extraction du second élément de chaque élément
# de la liste
lapply(u3, function(x) x[2])
```

Quand la chose est possible, **la fonction `sapply()` simplifie le résultat de la fonction `lapply()` pour obtenir en sortie une matrice ou un vecteur et non une liste**`r .fun("sapply", bold = TRUE)`. 

```{r}
u3

# Maximum de chaque élément de la liste avec lapply()
lapply(u3, max)

# Maximum de chaque élément de la liste avec sapply()
sapply(u3, max)
# Note : la syntaxe de sapply() est identique à celle
# de lapply(), la seule différence est dans le type
# de résultat renvoyé.

# Extraction des premier et troisième éléments 
# de chaque élément de la liste
sapply(u3, function(x) x[c(1, 3)])
# Note : quand sapply() ne peut pas renvoyer un vecteur, 
# il renvoie une matrice : quand sapply() ne peut pas renvoyer
# une matrice, il renvoie un liste. 
```

\ 

<!-- **La fonction `do.call()` permet enfin d'appliquer une fonction à l'ensemble des éléments d'une liste**`r .fun("do.call", bold = TRUE)` sans avoir à les indiquer explicitement. Elle est particulièrement utile pour **concaténer tous les éléments matriciels d'une liste avec `cbind()` ou `rbind()`**`r .fun("rbind", bold = TRUE)``r .fun("cbind", bold = TRUE)`. -->
<!-- ```{r} -->
<!-- # Création de la liste u4 -->
<!-- u4 <- list( -->
<!--   matrix(1:10, nrow = 2) -->
<!--   , matrix(11:20, nrow = 2) -->
<!--   , matrix(21:30, nrow = 2) -->
<!-- ) -->
<!-- u4 -->

<!-- # Concaténation "manuelle" des éléments de u4 -->
<!-- rbind(u4[[1]], u4[[2]], u4[[3]]) -->

<!-- # Concaténation automatique avec do.call() -->
<!-- do.call(rbind, u4) -->
<!-- # Note : le premier argument de do.call() est le nom -->
<!-- # de la fonction à appliquer et le second la liste -->
<!-- # sur laquelle l'appliquer.  -->
<!-- ``` -->


```{r,results = "asis", echo = FALSE}
.question("Effectuer des opérations sur les listes")
```

a. On définit les listes `v1 <- list(c(1, 2), c("a", "b", "c"), c(FALSE))` et `v2 <- list(c("k", "j"))`. Comparez `list(v1, v2)` et `c(v1, v2)`. D'où provient selon vous la différence ?`r .fun("c")`

```{r,results = "asis", echo = FALSE}
.beginsol()
```
```{r}
# Création de v1 et v2
v1 <- list(c(1, 2), c("a", "b", "c"), FALSE)
str(v1)
v2 <- list(c("k", "j"))
str(v2)

# Comparaison de list(v1, v2) et de c(v1, v2)
str(list(v1, v2))
str(c(v1, v2))

# list(v1, v2) est une liste imbriquée : elle 
# comporte deux éléments qui sont eux-mêmes des 
# listes (comptant l'une trois vecteurs et l'autre 
# un vecteur)

# c(v1, v2) est une liste de quatre éléments contenant
# directement les quatre mêmes vecteurs que list(v1, v2).
# Il n'y a pas de liste imbriquée dans c(v1, v2). 
```
```{r,results = "asis", echo = FALSE}
.endsol()
```

b. On définit `v3 <- c(v1, v2)`. Utilisez la fonction `lapply()` avec `mode()` pour déterminer le type de chaque élément de la liste `v3`. Comparez le résultat obtenu avec celui produit par `sapply()`.`r .fun("lapply")``r .fun("sapply")``r .fun("mode")`

```{r,results = "asis", echo = FALSE}
.beginsol()
```
```{r}
# Création de v3
v3 <- c(v1, v2)

# Pour connaître le type d'un objet, on utilise
# la fonction mode(). 
mode(v3[[2]])
# Le lapply() va juste servir à appliquer systématiquement
# la fonction mode() à chaque élément de v3
lapply(v3, mode)

# lapply() retourne toujours une liste en sortie
str(lapply(v3, mode))

# Quand c'est possible, sapply() simplifie le résultat
# de lapply() sous la forme d'un vecteur ou d'une matrice
sapply(v3, mode)

# Ici sapply() renvoie un vecteur de type caractère
str(sapply(v3, mode))
```
```{r,results = "asis", echo = FALSE}
.endsol()
```

c. En vous inspirant de la question précédente, extrayez automatiquement de `v3` la sous-liste des objets de type caractère.`r .fun("sapply")``r .fun("is.character")`

```{r,results = "asis", echo = FALSE}
.beginsol()
```
```{r}
v3

# Pour sélectionner une sous-liste à partir d'une
# liste, il suffit d'utiliser l'opérateur [
v3[c(TRUE, TRUE, FALSE, FALSE)]

# L'objectif est alors de produire un vecteur logique 
# permettant d'identifier les éléments de type caractère 
# de v3. 

# Méthode 1 : avec mode()
sapply(v3, mode) == "character"
v3[sapply(v3, mode) == "character"]

# Méthode 2 : avec is.character()
sapply(v3, is.character)
v3[sapply(v3, is.character)]

```
```{r,results = "asis", echo = FALSE}
.endsol()
```

<!-- d. (Optionnel) Que renvoie `unlist(v3)``r .fun("unlist", bold = TRUE)` ? Que fait la fonction `unlist()` à votre avis (pensez à utiliser l'aide avec `?`) ? En utilisant la fonction `do.call()``r .fun("do.call")`, reproduisez le comportement de `unlist()` (au moins dans le cas simple de `v3`).  -->

<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .beginsol() -->
<!-- ``` -->
<!-- ```{r} -->
<!-- str(v3) -->

<!-- # Test de unlist(v3) -->
<!-- unlist(v3) -->
<!-- # Il est clair que unlist() (comme son nom l'indique) -->
<!-- # va chercher à transformer une liste en un objet plus -->
<!-- # simple, en l'occurrence un vecteur.  -->

<!-- # On a vu que quand on dispose de deux vecteurs,  -->
<!-- # il suffit d'utiliser la fonction c() pour les -->
<!-- # concaténer -->
<!-- c(1:2, rep(3, times = 5)) -->

<!-- # On peut ainsi obtenir le même résultat que unlist() -->
<!-- # en appliquant la fonction c() à tous les éléments de v3 -->
<!-- c(v3[[1]], v3[[2]], v3[[3]], v3[[4]]) -->

<!-- # Pour appliquer automatiquement la fonction c()) v3,  -->
<!-- # on peut utiliser la fonction do.call() -->
<!-- do.call(c, v3) -->
<!-- # Note : le premier argument de do.call() est le nom -->
<!-- # de la fonction à appliquer (ici la fonction c()) et  -->
<!-- # le second la liste sur laquelle l'appliquer (ici v3). -->
<!-- ``` -->
<!-- ```{r,results = "asis", echo = FALSE} -->
<!-- .endsol() -->
<!-- ``` -->

<!--chapter:end:02-fondamentaux.Rmd-->

```{r, include = FALSE}
rm(list = ls())
if(!exists(".initOK")) source("init.R", encoding = "latin1")
.init()
```

```{r, results = "asis", echo = FALSE}
.module(numModule = 3, "Travailler avec des données statistiques")
```

\ 

L'objectif de ce troisième et dernier module est de **réutiliser dans un cadre \og métier \fg{} les briques élémentaires du langage** introduites dans le module précédent: 

- présentation du **type `data.frame`** et de ses relations avec les vecteurs, les matrices et les listes;
- **opérations courantes sur les tables de données statistiques**: sélection d'observations et de variables, création et modification de variables, tris, fusions, etc.;
- utilisation de R pour la **statistique descriptive et la production de graphiques**

En dernière partie, des **liens complémentaires** sont fournis vers le support de la formation R perfectionnement ainsi que vers des **exemples d'utilisation plus spécifiques** du logiciel (analyse de données multidimensionnelle, régression).

```{r, results = "asis", echo = FALSE}
.partie("Manipuler les `data.frame`")
```

Dans R, la majeure partie des données statistiques se présente sous la forme de **`data.frame`** : ces objets permettent en effet de **représenter sous la forme d'une table** (*i.e.* d'un objet à deux dimensions) **des données de nature tant quantitative** (variables numériques) **que qualitative** (variables de type caractère ou facteur). 


```{r, results = "asis", echo = FALSE}
.souspartie("Créer des data.frame et y sélectionner des éléments")
```

Pour créer un objet de type `data.frame`, il suffit d'**utiliser la fonction `data.frame()`**`r .fun("data.frame", bold = TRUE)`. 

```{r}
# Création du data.frame df1
df1 <- data.frame(
  var1 = 1:10
  , var2 = letters[1:10]
  , var3 = rep(c(TRUE, FALSE), times = 5)
)

# Caractéristiques de df1
str(df1)

# Premières lignes de df1
head(df1)
```

**Il est impératif que tous les éléments qui composent un `data.frame` soient de même longueur**. 
```{r, error = TRUE}
# Création du data.frame df3
df3 <- data.frame(
  var1 = 1:10
  , var2 = 1:15
)
```

\ 

------------------

**Remarque**  Par défaut, **la fonction `data.frame()` convertit les variables caractères en facteurs** (*cf.* `r .ref("module 2", "module2.html")`). Pour éviter ce comportement (pas toujours souhaitable), il suffit d'utiliser l'**argument `stringsAsFactors = FALSE`**.
```{r}
# Création du data.frame df2
df2 <- data.frame(
  var1 = 1:10
  , var2 = letters[1:10]
  , var3 = rep(c(TRUE, FALSE), times = 5)
  , stringsAsFactors = FALSE
)

# Caractéristiques de df2
str(df2)
# Note : dans df2, var2 est de type caractère alors que dans 
# df1 elle a été automatiquement convertie en factor. 
```

Pour empêcher la conversion de caractères en facteurs **pour toute une session**, il suffit de modifier l'option globale `stringsAsFactors`. 
```{r}
# Modification de l'option globale stringsAsFactors 
options(stringsAsFactors = FALSE)

# Désormais l'option stringsAsFactors n'est plus nécessaire 
# dans chaque appel de fonction
df3 <- data.frame(
  var1 = 1:10
  , var2 = letters[1:10]
  , var3 = rep(c(TRUE, FALSE), times = 5)
)
str(df3)
```

----

\ 

Du point de vue de sa structure, un `data.frame` est en réalité une **liste dont tous les éléments ont la même longueur** : c'est ce qui permet de le représenter sous la forme d'un **tableau à deux dimensions**`r .fun("is.list", bold = TRUE)``r .fun("lapply")`.
```{r}
# Un data.frame est une liste...
is.list(df1)

# ... dont tous les éléments sont de même longueur
lapply(df1, length)
```

De ce fait, **les `data.frame` empruntent leurs caractéristiques tantôt aux listes, tantôt aux matrices** : 

- Comme une matrice, un `data.frame` a **deux dimensions** (fonction `dim()``r .fun("dim")``r .fun("ncol")``r .fun("nrow")`) ; mais comme une liste, sa **longueur** (fonction `length()``r .fun("length")`) correspond à son nombre d'éléments (son nombre de variables). 
    ```{r}
# Dimensions de df1 : comme une matrice
dim(df1)
nrow(df1)
ncol(df1)

# Longueur de df1 : comme une liste
length(df1)
    ```

\ 

- Comme avec une matrice, on accède aux noms de lignes et de colonne d'un `data.frame` avec les fonctions **`rownames()` et `colnames()`**`r .fun("rownames")``r .fun("colnames")` ; mais comme avec une liste, les noms de colonnes sont aussi directement accessibles avec **`names()`**`r .fun("names")`. 
    ```{r}
# rownames() et colnames() : comme avec une matrice
rownames(df1)
colnames(df1)

# names() : comme avec une liste
names(df1)
    ```

\ 

- Comme avec une matrice, il est possible d'accéder aux éléments d'un `data.frame` en **indiquant leurs deux positions dans un opérateur `[`**`r .fun("[")` ; mais comme avec une liste, **il est également possible d'utiliser les opérateurs ` [[` et `$`**`r .fun("[[")``r .fun("\\$")`. 
    ```{r}
df1
# On cherche à accéder à l'élément en ligne 8, colonne 2 de df1

# - comme une matrice : avec `[` et deux positions 
df1[8, 2]
df1[8, "var2"]

# - comme une liste : avec `[[` pour sélectionner la colonne,
# puis [ pour sélectionner la ligne
df1[[2]][8]
df1[["var2"]][8]

# - comme une liste : avec `$` pour sélectionner la colonne,
# puis [ pour sélectionner la ligne
df1$var2[8]
    ```

\ 

Les **fonctions `as.matrix()`, `as.list()` et `as.data.frame()`**`r .fun("as.matrix", bold = TRUE)``r .fun("as.list", bold = TRUE)``r .fun("as.data.frame", bold = TRUE)` permettent de convertir un `data.frame` en liste ou en matrice, et inversement. 
```{r}
# Conversion de df1 en matrice
as.matrix(df1)
# Note : au passage les variables ont toutes été converties
# en caractères, car une matrice ne peut avoir qu'un seul
# et unique type

# Conversion de df1 en liste
as.list(df1)
# Note : on n'a pas à proprement parler affaire ici à une
# "conversion" (un data.frame est une liste) mais plutôt
# à la suppression de certains attributs spécifiques aux
# data.frame (noms de ligne notamment)
rownames(df1)
rownames(as.list(df1))

# Conversion d'une matrice en data.frame
as.data.frame(matrix(1:10, ncol = 5))

# Conversion d'une liste en data.frame
as.data.frame(list(a = 1:5, b = letters[5:1]))
# Note : dans ce cas il est également impératif
# que tous les éléments de la liste aient bien la même
# longueur. 
```


```{r,results = "asis",echo = FALSE}
.question("Sélectionner des variables et des observations dans une table")
```

Ce cas pratique aborde plusieurs **manipulations courantes de sélection de variables et d'observations dans une table**. Comme la plupart des cas pratiques de ce module, il repose sur l'utilisation des données de l'[enquête Emploi en continu 2012](https://www.insee.fr/fr/metadonnees/source/s1223) restreinte au quatrième trimestre et aux individus en première ou sixième interrogation. Ces données correspondent au fichier `eect4.rds` contenu dans le fichier `r .ref("donnees.zip", "donnees.zip", "http://r.slmc.fr/donnees.zip")`. 

a. Après avoir modifié le répertoire de travail avec `setwd()`, utilisez la fonction `readRDS()``r .fun("readRDS")` pour charger le fichier `eect4.rds` dans l'objet `eec` (*cf.* la remarque finale du `r .ref("module 1", "module1.html")` pour l'utilisation de la fonction `readRDS()`).

    ```{r,results = "asis",echo = FALSE}
    .beginsol()
    ```
    
    ```{r, eval=FALSE}
    # Définition du répertoire de travail (répertoire personnel sous AUS)
    setwd("Y:/Documentation/R/R_initiation/donnees")
    ```
    ```{r}
    # Chargement des données de l'EEC du 2015T4 depuis le fichier eect4.rds
    eec <- readRDS("eect4.rds")
    
    # Caractéristiques de l'objet eec
    str(eec)
    ```
    ```{r,results = "asis",echo = FALSE}
    .endsol()
    ```

b. Pour simplifier le travail sur cette table, on souhaite normaliser la casse des noms de variable. Proposez une méthode pour passer l'ensemble des noms de variable en minuscules et appliquez-la.`r .fun("tolower")``r .fun("names")`

    ```{r, results = "asis", echo = FALSE}
    .indic("**Indication** Pensez à utiliser les fonctions `names()` et `tolower()`.")
    ```

    ```{r,results = "asis",echo = FALSE}
    .beginsol()
    ```
    
    ```{r}
    # Pour accéder aux noms de variable de eec, on peut
    # utiliser au choix les fonctions names() ou colnames()
    names(eec)
    
    # Pour changer la casse des noms de variables, il suffit
    # de remplacer ce vecteur de noms par sa version 
    # en minuscules. Pour ce faire, on utilise la fonction tolower()
    tolower(names(eec))
    
    # Il ne reste plus qu'à remplacer les noms originaux par
    # les noms passés en minuscules
    names(eec) <- tolower(names(eec))
    str(eec)
    ```
    ```{r,results = "asis",echo = FALSE}
    .endsol()
    ```

c. On souhaite créer deux nouvelles tables ne contenant que les variables sur lesquelles portent différents aspects de l'étude :

    i. `eec2` qui ne contienne que les variables `ident`, `noi`, `acteu` et `extri1613`.`r .fun("[")`
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # On utilise l'opérateur `[` avec le vecteur caractère des
        # noms des variables à conserver
        eec2 <- eec[, c("ident", "noi", "acteu", "extri1613")]
        head(eec2)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    ii. `eec3` qui contienne toutes les variables de `eec` à l'exception  de `cse`.`r .fun("setdiff")`

        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Comment utiliseriez-vous les opérations ensemblistes sur les vecteurs (*cf.* module 2) pour créer le vecteur des noms des variables de la table `eec` SAUF `cse` ? Utilisez-le comme au i. pour sélectionner toutes les variables sauf `cse`.")
        ```

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La méthode la plus générale pour répondre à la question
        # consiste à construire le vecteur des noms des variables
        # de eec à l'exception de cse puis de l'utiliser comme au i. 
        
        # Le vecteur des noms de variables de eec est obtenu avec la
        # fonction names()
        names(eec)
        
        # Pour supprimer un ou plusieurs éléments de ce vecteur, il 
        # suffit d'utiliser la fonction setdiff() (cf. module 2) : 
        setdiff(names(eec), c("cse"))
        
        # Il n'y a plus qu'à utiliser ce vecteur caractère pour 
        # sélectionner les variables correspondantes de eec
        eec3 <- eec[, setdiff(names(eec), c("cse"))]
        names(eec3)
        
        # Remarque : une méthode un peu moins directe repose sur 
        # l'utilisation de vecteurs logiques 
        # L'idée est de renvoyer le vecteur logique des variables
        # à conserver, de la façon suivante : 
        names(eec) != "cse"
        eec3b <- eec[, names(eec) != "cse"]
        identical(eec3, eec3b)
        
        # Cette méthode ne peut facilement fonctionner en tant que
        # telle que quand on ne souhaite supprimer qu'une seule
        # variable. Pour supprimer plusieurs variables en restant
        # dans la même logique, on peut utiliser l'opérateur %in%
        # et la négation !. 
        
        # Ainsi pour supprimer conjointement cse et extri1613 : 
        !(names(eec) %in% c("cse", "extri1613"))
        eec3c <- eec[, !(names(eec) %in% c("cse", "extri1613"))]
        
        # Avec setdiff(), on aurait fait : 
        eec3d <- eec[, setdiff(names(eec), c("cse", "extri1613"))]
        identical(eec3c, eec3d)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

d. On souhaite désormais créer une nouvelle table `eec4` contenant toutes les variables mais uniquement pour les individus appartenant à la population active (`acteu` vaut `"1"` ou `"2"`). Comment procéderiez-vous ?`r .fun("\"|")``r .fun("\\%in\\%")` 

    ```{r,results = "asis",echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # On commence par évaluer l'expression logique correspondant 
    # à la sélection que l'on souhaite effectuer
    str(eec$acteu %in% c("1","2"))
    
    # Nombre d'individus concernés
    sum(eec$acteu %in% c("1","2"))

    # Dès lors que les observations à sélectionner sont identifiées 
    # par un vecteur logique, on peut le réutiliser dans
    # l'opérateur `[` pour restreindre la table aux observations souhaitées. 
    eec4 <- eec[eec$acteu %in% c("1","2"), ]
    nrow(eec4)

    # On vérifie qu'il n'y a bien plus aucun inactif (acteu == "3") dans eec4
    sum(eec4$acteu == "3")
    
    # Remarque : pour effectuer la sélection, on aurait aussi 
    # pu utiliser l'expression : 
    str(eec$acteu == "1" | eec$acteu == "2")
    # Néanmoins, en présence de valeurs manquantes NA
    # == et %in% ne conduisent pas aux mêmes résultats
    sum(eec$acteu == "1" | eec$acteu == "2", na.rm = TRUE)
    
    # La variable acteu compote en effet des valeurs NA, 
    # qui interagissent de façon particulière avec l'opérateur
    # ==
    sum(is.na(eec$acteu))
    
    # Un petit exemple pour mieux voir la différence entre == et %in% :
    v <- c(1, 2, 3, 4, NA)
    v == 3
    v %in% 3
    
    # De manière générale, en présence de NA on recommande
    # d'utiliser systématiquement le signe %in% à la place
    # du ==. 
    ```
    ```{r,results = "asis",echo = FALSE}
    .endsol()
    ```


```{r, results = "asis", echo = FALSE}
.souspartie("Créer ou modifier des variables dans un `data.frame`")
```

Pour créer une nouvelle variable dans un `data.frame`, **le plus simple est d'utiliser l'opérateur `$`**. `r .fun("\\$")`
```{r}
# Création du data.frame df5
df5 <- data.frame(
  var1 = letters[1:4]
  , var2 = rep(c(FALSE, TRUE), times = 2)
  , stringsAsFactors = FALSE
)
df5

# Ajout de la variable var3 avec $
df5$var3 <- (1:4)^2
df5
```

Pour créer une variable **à partir d'une ou plusieurs autres de la table**, il suffit d'**utiliser l'opérateur `$` plusieurs fois**. 
```{r}
# Création de la variable var4 à partir de var3
df5$var4 <- df5$var3 * 2
df5

# Conversion de var2 de logique vers numérique
df5$var2 <- as.numeric(df5$var2)
df5
# Note : modifier à la volée une variable existante ne pose 
# aucun problème
```

Pour effectuer un **recodage manuel selon une ou plusieurs conditions** (comme un IF THEN ELSE dans SAS), trois méthodes sont disponibles : 

1. Pour les variables dichotomiques uniquement, **utiliser des opérateurs logiques** pour créer un nouveau vecteur.

    ```{r}
    # Création de la variable var5 valant TRUE si var4 > 10 et var2 = 1
    df5$var5 <- df5$var4 > 10 & df5$var2 == 1
    df5
    ```

2. Créer la variable recodée progressivement en **utilisant l'opérateur `[`**`r .fun("[")`.

    ```{r}
    # Création de la variable var6 identique à var5
    df5$var6 <- "Non"
    df5$var6[df5$var4 > 10 & df5$var2 == 1] <- "Oui"
    df5
    ```

3. **Utiliser la fonction `ifelse()`**.`r .fun("ifelse", bold = TRUE)`

    ```{r}
    # Création de la variable var7 identique à var5 et var6
    df5$var7 <- ifelse(df5$var4 > 10 & df5$var2 == 1, "Oui", "Non")
    df5
    ```

    La fonction `ifelse()` prend trois arguments : l'expression logique à évaluer, la valeur à renvoyer si l'expression est vraie, la valeur à renvoyer si l'expression est fausse. Il est possible **d'imbriquer des fonctions `ifelse()`** pour effectuer des recodages complexes.
    
\ 
    
-----

**Remarque** Savoir tirer parti de la fonction `within()``r .fun("within", bold = TRUE)`

Quand on met en oeuvre un recodage, on est fréquemment amené à **répéter le nom du `data.frame` sur lequel on travaille**. **La fonction `within()` permet d'alléger l'écriture d'un recodage** et de faciliter la compréhension d'un code en évitant cette répétition.`r .fun("paste0")`

```{r}
# Concaténation manuelle des variables var1 à var4
df5$var7 <- paste0(df5$var1, df5$var2, df5$var3, df5$var4)

# Syntaxe allégée avec la fonction within()
# Création de la variable var5, concaténation de 
# toutes les autres variables de la table df5
df5 <- within(df5, {
  var8 <- paste0(var1, var2, var3, var4)
})
df5[, c("var7", "var8")]
```

Le premier argument de `within()` est le nom du `data.frame` sur lequel porte le recodage, le second est la série d'instructions à appliquer (les accolades sont obligatoires s'il y a plus d'une instruction). 

------

\ 

```{r,results = "asis",echo = FALSE}
.question("Recoder des variables")
```

Ce cas pratique vise à appliquer les opérations de création et de modification de variables présentées dans cette partie à des données statistiques classiques. Comme le précédent, il porte sur les données de l'enquête Emploi en continu au 2015T4. 

a. La variable `cse` code la Profession et catégorie socioprofessionnelle (PCS) des individus en 42 postes (*cf.* [cette page](https://www.insee.fr/fr/information/2400059) pour plus de détails). On souhaite créer la variable agrégée `cs` qui ne conserve que la première position de la nomenclature. 

    i. Proposez une première méthode (un peu fastidieuse) s'appuyant sur des recodages manuels avec l'opérateur `[` `r .fun("[")``r .fun("within")``r .fun("\\%in\\%")`.
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # On commence par regarder les valeurs prises par eec$cse
        table(eec$cse)
        
        # On recode les différents cas un à un avec `[`
        eec$cs <- eec$cse
        eec$cs[eec$cs %in% c("11", "12", "13")] <- "1"
        eec$cs[eec$cs %in% c("21", "22", "23")] <- "2"
        eec$cs[eec$cs %in% c("31", "33", "34", "35", "37", "38")] <- "3"
        eec$cs[eec$cs %in% c("42", "43", "44", "45", "46", "47", "48")] <- "4"
        eec$cs[eec$cs %in% c("52", "53", "54", "55", "56")] <- "5"
        eec$cs[eec$cs %in% c("62", "63", "64", "65", "67", "68", "69")] <- "6"
        eec$cs[eec$cs  == "81"] <- "8"
        
        # On vérifie ce qu'il reste dans eec$cs
        table(eec$cs)
        eec$cs[eec$cs  == "00"] <- "0"
        table(eec$cs)
        
        # Amélioration : la même chose mais dans un within()
        eec <- within(eec, {
          cs <- cse
          cs[cs %in% c("11", "12", "13")] <- "1"
          cs[cs %in% c("21", "22", "23")] <- "2"
          cs[cs %in% c("31", "33", "34", "35", "37", "38")] <- "3"
          cs[cs %in% c("42", "43", "44", "45", "46", "47", "48")] <- "4"
          cs[cs %in% c("52", "53", "54", "55", "56")] <- "5"
          cs[cs %in% c("62", "63", "64", "65", "67", "68", "69")] <- "6"
          cs[cs  == "81"] <- "8"
          cs[cs  == "00"] <- "0"
        })
        table(eec$cs)
        ```    
        ```{r,results = "asis",echo = FALSE}
        .endsol()
    ```

    ii. Effectuez le même recodage en utilisant la fonction `substr()`.`r .fun("substr", bold = TRUE)`

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        
        # La fonction substr() permet de sélectionner
        # des caractères dans une chaîne
        substr(c("abcd", "efgh", "ijkl"), start = 2, stop = 3)
        
        # Application à l'EEC
        eec$cs2 <- substr(eec$cse, start = 1, stop = 1)
        
        # On vérifie qu'on obtient bien la même chose par les deux méthodes
        identical(eec$cs, eec$cs2)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


b. La variable de position sur le marché du travail (`acteu`) comporte des valeurs manquantes dans le fichier `eec` à votre disposition. On souhaite imputer cette variable de façon déterministe : 

    - si la personne est âgée de moins de 67 ans, on considère qu'elle est active occupée (`acteu` vaut `"1"`) ;
    - si la personne est âgée de 67 ans ou plus, on considère qu'elle est inactive (`acteu` vaut `"3"`). 

    -------------
    
    **Remarque** Le fichier original de l'enquête Emploi en continu ne comporte aucune valeur manquante pour la variable `acteu`, celles-ci ont été ajoutées pour l'exercice. 
    
    -------------
    
    i. Utilisez la fonction `table()``r .fun("table")` pour affichez le nombre de valeurs `NA` dans la variable `acteu`. Créez la table `eec_pb` ne comportant que les individus pour lesquels la variable `acteu` vaut `NA`. 
 
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pour créer la table `eec_pb`, pensez à utiliser la fonction `is.na()`.")
        ```   
  
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La fonction table() produit un tri à plat d'une variable
        table(eec$acteu)
        
        # Pour afficher les valeurs NA, il convient d'utiliser
        # l'argument useNA = "always"
        table(eec$acteu, useNA = "always")
        
        # Création de la table eec_pb
        eec_pb <- eec[is.na(eec$acteu), ]
        head(eec_pb)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

        
    ii. Dans la table `eec`, créez la variable redressée `acteu_red` en mettant en oeuvre la procédure d'imputation (très frustre) décrite ci-dessus. 

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # On effectue l'imputation décrite ci-dessus
        eec <- within(eec, {
          acteu_red <- acteu
          acteu_red[is.na(acteu) & age < "67"] <- "1"
          acteu_red[is.na(acteu) & age >= "67"] <- "3"
        })
        table(eec$acteu_red, useNA = "always")
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```
        
    iii. Recréez la table `eec_pb` et contrôlez que l'imputation s'est déroulée correctement (en vérifiant que les valeurs imputées sont cohérentes avec l'âge des individus).

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Re-création de la table eec_pb et contrôle
        # des valeurs de acteu_red
        eec_pb <- eec[is.na(eec$acteu), ]
        head(eec_pb[, c("age", "acteu", "acteu_red")])
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


c. Le vecteur de poids de l'enquête (variable `extri1613`) présente des valeurs extrêmes relativement élevées. Afin d'éviter que les estimations ne soient trop affectées par quelques individus atypiques, on souhaite limiter le poids des individus en les "rabotant" à la valeur du 99ème percentile. 

    i. Utilisez la fonction `quantile()` pour calculer le 99ème percentile de la distribution de `extri1613``r .fun("quantile")`. 
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La fonction quantile() calcule les quantiles d'une distribution
        quantile(eec$extri1613)
        
        # Pour récupérer un quantile en particulier, on utilise l'argument
        # probs 
        seuil <- quantile(eec$extri1613, probs = 0.99)
        seuil
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    
    ii. Récupérer la valeur du 99ème percentile et utilisez-la pour créer une nouvelle pondération (`newpond`) dans laquelle les poids ont été "rabotés" à son niveau.

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # On utilise la valeur de seuil pour créer une version
        # modifiée de la pondération (par exemple avec ifelse())
        eec$newpond <- ifelse(
          eec$extri1613 > seuil
          , seuil
          , eec$extri1613
        )
        
        # Caractéristiques générales de newpond
        summary(eec$newpond)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


```{r, results = "asis", echo = FALSE}
.souspartie("Modifier la structure d'un `data.frame`")
```

Comme pour les vecteurs ou les matrices, plusieurs opérations permettent de **modifier la structure d'un `data.frame`** : 

- **trier un `data.frame` avec `order()`**`r .fun("order", bold = TRUE)` : contrairement aux vecteurs, il n'est pas possible d'utiliser la fonction `sort()` pour trier un `data.frame`. En revanche, **la fonction `order()` renvoie la permutation permettant de trier une table selon une ou plusieurs variables**. 
```{r}
# Création de la table df6
df6 <- data.frame(
  var1 = letters[c(3, 4, 2, 5, 1, 5, 2, 4, 3, 1)]
  , var2 = rnorm(10))
df6

# Tri selon la variable var1
# - Etape 1 : obtention de la permutation correspondante
order(df6$var1)
# Utilisée sur le vecteur df6$var1, cette permutation
# renvoie un vecteur trié
df6$var1
order(df6$var1)
df6$var1[order(df6$var1)]

# - Etape 2 : utilisation de la permutation pour trier df6
df6[order(df6$var1), ]

# Tri selon la variable var1 puis la variable var2
# - Etape 1 : obtention de la permutation correspondante
order(df6$var1, df6$var2)
# - Etape 2 : utilisation de la permutation pour trier
df6[order(df6$var1, df6$var2), ]

# Tri selon la variable var1 puis les valeurs décroissantes
# de var2
df6 <- df6[order(df6$var1, - df6$var2), ]
df6
```

\ 

- ne sélectionner **que les valeurs distinctes pour certaines variables avec `unique()`**`r .fun("unique", bold = TRUE)` : la fonction `unique()` utilisée sur les vecteurs est également applicable aux `data.frame`. 
```{r}
# Ajout de la variable var3
df6$var3 <- rep(1:2, each = 5)
df6

# Sélection de toutes les valeurs distinctes de var1 et var3
unique(df6[,c("var1", "var3")])
```

\ 

- **ajouter des lignes ou des colonnes à un `data.frame`** avec les fonctions `cbind()``r .fun("cbind", bold = TRUE)` et `rbind()``r .fun("rbind", bold = TRUE)`.
```{r, error = TRUE}
# Création du data.frame df7
df7 <- data.frame(
  var1 = c("f","f")
  , var2 = rnorm(2)
  , var3 = 3
)
df7

# Création du data.frame df8 par concaténation des lignes 
# de df6 et de df7
df8 <- rbind(df6, df7)
df8

# Note : il faut que les deux data.frame aient exactement
# les mêmes variables avec le même nom pour que cela fonctionne
rbind(df6, df7[, c("var1", "var3")])
```

\ 

- **fusionner des données sur la base d'un identifiant** : la fonction `merge()``r .fun("merge", bold = TRUE)` permet de fusionner deux `data.frame` (pas plus) sur la base d'un identifiant. À noter que **les tables n'ont pas besoin d'être triées au préalable**. 

```{r}
# Création du data.frame df9
df9 <- data.frame(
  var3 = 2:4
  , var4 = c(TRUE, FALSE, TRUE)
)
df9

# Fusion de df8 et de df9 selon la variable var3
merge(df8, df9, by = "var3")
# Par défaut, merge() se restreint aux valeurs communes aux deux tables.

# Conservation de toutes les observations de df8 avec all.x = TRUE
merge(df8, df9, by = "var3", all.x = TRUE)

# Conservation de toutes les observations de df9 avec all.y = TRUE
merge(df8, df9, by = "var3", all.y = TRUE)
```
    
À noter qu'il peut y avoir **plusieurs variables de fusion** et qu'**il n'est pas indispensable qu'elles aient le même nom**.

```{r}
# Création du data.frame df10
df10 <- data.frame(
  v1 = c("c","f")
  , v3 = c(2, 3)
  , v5 = c("Rouge", "Bleu")
)
df10

# Fusion de df8 et de df10
merge(df8, df10, by.x = c("var3", "var1"), by.y = c("v3", "v1"), all = TRUE)
```


```{r,results = "asis",echo = FALSE}
.question("Modifier la structure de données statistiques")
```


a. À partir de la table `eec`, on souhaite produire une nouvelle table (`eec5`) qui ne comporte qu'un individu par ménage, le plus âgé. Les ménages sont identifiés par la variable `ident` et la variable `age` code l'âge des individus. 

    i. Comment détermineriez-vous le nombre de ménages dans la table `eec` ?`r .fun("unique")`

        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pensez à utiliser la fonction `unique()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # La fonction unique(), appliquée à un vecteur ou à une table,
        # permet de déterminer des valeurs distinctes. 
        # Déterminer le nombre de valeurs distinctes revient ainsi 
        # à déterminer la longueur du vecteur ou le nombre de lignes
        # de la table renvoyé par la fonction unique()
        length(unique(eec$ident))
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


    ii. On cherche d'abord à constituer une table ne comportant qu'un seul individu par ménage, quel que soit son âge. Comment procéderiez-vous ?`r .fun("duplicated")`
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pensez à utiliser la fonction `duplicated()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Pour un vecteur donné, la fonction duplicated() renvoie
        # TRUE si l'élément figure déjà parmi les éléments du vecteur
        # d'indice inférieur. 
        # Par exemple : 
        duplicated(c(1, 2, 3, 1, 1, 4, 3))
        # Indique que les éléments en position 4, 5 et 8 sont en double
        # (ils apparaissent déjà dans le vecteur).
        
        # Cette fonction peut être utilisée pour ne sélectionner
        # qu'un seul individu par ménage
        str(!duplicated(eec$ident))
        # Note : On utilise ici str() afin que le vecteur logique
        # ne s'affiche pas en entier (il compte plus de 30 000 éléments !)
        
        # Il ne reste donc plus qu'à utiliser ce vecteur logique
        # pour sélectionner les observations de eec. 
        eec5 <- eec[!duplicated(eec$ident), ]
        head(eec5)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    iii. Comment adapteriez-vous la réponse à la question précédente pour sélectionner l'individu le plus âgé du ménage (sans chercher à maîtriser celui qui est sélectionné quand plusieurs membres d'un même ménage ont le même âge) ?`r .fun("order")`
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pensez à trier judicieusement la table avec `order()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # duplicated() procède sur le vecteur des identifiant
        # tel qu'il est trié dans la base eec
        
        # En triant la base eec judicieusement, il est possible
        # de déterminer quel individu du ménage est conservé dans
        # la table eec5.
        
        # En l'occurrence, il suffit de trier la table eec :
        # - par ménage
        # - PUIS par âge décroissant
        
        # Pour mener à bien le tri, on utilise la fonction order() : 
        # - permutation pour trier par identifiant
        str(order(eec$ident))
        # - permutation pour trier par identifiant puis par âge
        str(order(eec$ident, eec$age))
        # - permutation pour trier par identifiant puis par âge décroissant
        str(order(eec$ident, - eec$age))
        
        # Note : On utilise ici str() afin que le vecteur logique
        # ne s'affiche pas en entier (il compte plus de 30 000 éléments !)

        # Le dernier appel de la fonction order() produit une erreur : 
        # la variable age étant de type caractère, l'opérateur -
        # ne peut lui être appliqué. 
        # Pour ce faire, il suffit de convertir la variable 
        # age au préalable en vecteur de type numérique
        str(order(eec$ident, - as.numeric(eec$age)))
        
        # On peut donc procéder au tri en tant que tel :
        eec <- eec[order(eec$ident, - as.numeric(eec$age)), ]
        eec[1:10, c("ident", "age")]
        # Il semble bien que la table soit triée par ident puis par âge décroissant.
        
        # Il ne reste plus qu'à utiliser la même méthode 
        # qu'à la question précédente :
        eec5 <- eec[!duplicated(eec$ident), ]
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    iv. (Optionnel) Comment adapteriez-vous la réponse à la question précédente pour effectuer un tirage au sort quand plusieurs membres d'un même ménage ont le même âge ?`r .fun("rnorm")`
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pensez à utiliser une variable aléatoire (générée par exemple avec `rnorm()` ou `runif()`) dans la fonction `order()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # En l'état et quand plusieurs individus ont l'âge le plus élevé
        # dans un ménage, l'individu sélectionné dans eec5 est celui
        # qui était situé en premier dans la base eec. 
        
        # Néanmoins l'ordre de la base eec n'est pas aléatoire, 
        # et on peut souhaiter qu'en cas d'égalité l'individu
        # sélectionné le soit aléatoirement.
        
        # Une méthode très simple pour atteindre cet objectif consiste
        # à ajouter une variable aléatoire comme ultime variable de tri. 
        
        # Pour ce faire, on utilise la fonction de génération 
        # de variables aléatoires rnorm(). Par exemple 
        rnorm(5)
        # génère un vecteur de longueur 5 tiré dans une loi 
        # normale centrée réduite. 
        
        # Ici on va avoir besoin d'un vecteur de longueur
        # le nombre de ligne de eec, aussi on va utiliser : 
        alea <- rnorm(nrow(eec))
        str(alea)
        
        # On peut alors compléter la fonction order() de la sous-question
        # précédente en ajoutant le vecteur alea comme troisième variable
        # de tri :  
        eec <- eec[order(eec$ident, - as.numeric(eec$age), alea), ]
        eec[1:10, c("ident", "age")]
        eec6 <- eec[!duplicated(eec$ident), ]
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

b. Retour sur les PCS. Entre le niveau de la variable `cse` (niveau 3) et le niveau le plus agrégé de la variable `cs` créée dans le cas pratique 3.1 (niveau 1), il existe un niveau intermédiaire (niveau 2). La correspondance entre le niveau 3 et le niveau 2 n'est pas directe, et en règle générale on utilise la table de passage `pcs2003_c_n4_n1.dbf` (téléchargée depuis le [site de l'Insee](https://www.insee.fr/fr/information/2400059)) pour la réaliser. 

    i. Utilisez le *package* `foreign` et la fonction `read.dbf``r .fun("read.dbf", bold = TRUE)` pour importer cette table dans R. La nomenclature comporte quatre niveaux, mais le quatrième (variable `N4`) ne nous intéresse pas : agrégez la table de façon à ne conserver que les valeurs distinctes pour les niveaux 2 et 3 de la nomenclature`r .fun("unique")`. 
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Pensez à utiliser la fonction `unique()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La fonction read.dbf() du package foreign permet de 
        # facilement importer des fichiers .dbf sous forme de data.frame
        library(foreign)
        passage <- read.dbf("pcs2003_c_n4_n1.dbf")
        str(passage)
        
        # Pour ne conserver que les valeurs distinctes pour
        # les variables N2 et N3, il suffit d'utiliser
        # la fonction unique sur le data.frame restreint
        # aux variables N2 et N3 :
        passage <- unique(passage[, c("N2", "N3")])
        str(passage)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


    
    ii. Utilisez la fonction `merge()``r .fun("merge")` pour fusionner cette table de passage avec le fichier `eec` et créer une nouvelle table (`eec6`) contenant une variable supplémentaire correspondant au niveau 2 de la PCS.
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Prenez garde au type des variables de fusion (qui doit être identique), ainsi qu'au nombre d'observations dans la table de départ et la table d'arrivée.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La variable cse de la table eec est de type caractère, alors que
        # N2 dans la table passage est de type numérique. On commence
        # donc par convertir N2 en variable caractère
        passage$N2 <- as.character(passage$N2)
        
        # On utilise alors la fonction merge() pour fusionner les tables
        # eec et passage. 
        # Note : on utilise l'option all.x = TRUE pour conserver 
        # toutes les observations de eec, mais pas les observations
        # de passage sans correspondance dans eec
        eec6 <- merge(eec, passage, by.x = "cse", by.y = "N3", all.x = TRUE)
        
        # Quand on compare les tris à plat de cse et N2, on constate
        # que des valeurs manquantes sont apparues
        table(eec6$cse, useNA = "always")
        table(eec6$N2, useNA = "always")
        # En fait ce sont les 4 cas de 00 (absent de la table passage)
        # qui sont conservés grâce à all.x = TRUE mais avec une valeur
        # manquante à N2. 
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```
    
    iii. (Difficile) À partir de la table de passage agrégée à la sous-question i., créez le vecteur `n2` dont les éléments sont les valeurs de la variable N2 et dont les noms sont les valeurs de la variable N3. Comment pourriez-vous utiliser ce vecteur pour obtenir le même résultat qu'à la question ii. ?`r .fun("na.omit", bold = TRUE)`
    
        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Comparez `eec$cse[1:10]` et `n2[eec$cse[1:10]]`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Construction du vecteur n2
        n2 <- passage$N2
        names(n2) <- passage$N3
        str(n2)
        n2[1:10]
        
        # Remarque : on peut faire les deux opérations d'un seul 
        # coup avec la fonction setNames()
        n2 <- setNames(passage$N2, passage$N3)
        
        # Comme proposé, on compare eec$cse[1:10] et n2[eec$cse[1:10]]
        eec$cse[1:10]
        n2[eec$cse[1:10]]
        # Les deux vecteurs se ressemblent avec quelques différences : 
        # - le premier est un vecteur dont les éléments sont les valeurs
        # de la PCS au niveau 3 pour les 10 premiers individus de la base
        # - le second est un vecteur dont les noms sont les valeurs 
        # de la PCS au niveau 3 et dont les éléments sont les valeurs 
        # de la PCS au niveau 2 pour les 10 premiers individus de la base.
        
        # Un exemple plus simple : 
        aConvertir <- c("b", "d", "a", "e", "a", "f")
        aConvertir
        corresp <- setNames(rep(1:3, each = 2), letters[1:6])
        corresp
        corresp[aConvertir]
        
        # Pour revenir à la question : il suffit alors d'utiliser
        # le vecteur n2[eec6$cse] pour créer directement la variable
        # convertie dans la table eec6
        eec6$N2_bis <- n2[eec6$cse]
        identical(eec6$N2, eec6$N2_bis)
        
        # Cette méthode, beaucoup plus efficace que celle du ii., 
        # est présentée plus en détails dans la formation 
        # perfectionnement.
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```



```{r, results = "asis", echo = FALSE}
.souspartie("Effectuer des calculs sur un `data.frame`")
```

La proximité des `data.frame` avec les listes se retrouve dans le **type d'opérations qu'il est possible de leur appliquer** : comme avec les listes, il est possible d'utiliser les **fonctions `lapply()` et `sapply()`**`r .fun("lapply")``r .fun("sapply")`, qui s'appliquent **colonne par colonne**.

```{r}
df11 <- data.frame(
  var1 = 1:5
  , var2 = 11:15
  , var3 = 21:25
)
df11
  
# lapply(), sapply() : comme une liste
lapply(df11, sum)
sapply(df11, mean)
```

\ 

Une des opérations les plus utiles consiste à **appliquer une même fonction à des groupes d'observations définis par les modalités d'une autre variables** (comme avec une **instruction BY dans SAS**).

**Exemple** Âge moyen par région, salaire moyen par sexe, etc. 

\ 

Plusieurs fonctions de R permettent de mener à bien ce type d'opération : 

- la **fonction `aggregate()`**`r .fun("aggregate", bold =  TRUE)` ;

    ```{r}
    df6
    # On souhaite calculer la moyenne de var2
    # selon les modalités de var3
    
    aggregate(df6$var2, list(df6$var1), mean)
    ```

- la **fonction `tapply()`**`r .fun("tapply", bold = TRUE)` ;

    ```{r}
    tapply(df6$var2, df6$var1, mean)
    ```

- la **fonction `split()` combinée à un `lapply()` ou un `sapply()`**`r .fun("split", bold = TRUE)``r .fun("lapply")``r .fun("sapply")`.

    ```{r}
    # La fonction split(x, f) "éclate" le data.frame x en une 
    # liste de data.frame selon les modalités du factor f
    split(df6, df6$var1)
    
    # Il ne reste alors plus qu'à appliquer
    # à chaque élément de la liste ainsi produite 
    # la fonction souhaitée par le biais d'un sapply()
    sapply(split(df6, df6$var1), function(x) mean(x$var2))
    ```


--------------

**Remarques** 

1. Les performances de ces méthodes diffèrent sensiblement`r .fun("microbenchmark", bold = TRUE)` : 

```{r benchmark, eval=FALSE}
# Installation et chargement de la bibliothèque de test 
# de performance microbenchmark
# install.packages("microbenchmark")
library(microbenchmark)

# Compararison des trois méthodes + variante optimisée de sapply()
microbenchmark(times = 1000
  , aggregate = aggregate(df6$var2, list(df6$var1), mean)
  , sapply = sapply(split(df6, df6$var1), function(x) mean(x$var2))
  , tapply = tapply(df6$var2, df6$var1, mean)
  , sapply2 = sapply(split(df6$var2, df6$var1), mean)
)
```

```{r, echo=FALSE}
if(!(".bench1.RData" %in% list.files(all.files = TRUE))){
  .bench1 <- microbenchmark(times = 1000
    , aggregate = aggregate(df6$var2, list(df6$var1), mean)
    , sapply = sapply(split(df6, df6$var1), function(x) mean(x$var2))
    , tapply = tapply(df6$var2, df6$var1, mean)
    , sapply2 = sapply(split(df6$var2, df6$var1), mean)
  )
  save(.bench1, file = ".bench1.RData")
}
load(".bench1.RData")
.bench1
```


2. Le [*package* `sqldf`](http://www.gettinggeneticsdone.com/2010/05/use-sql-queries-to-manipulate-data.html) permet d'utiliser le langage SQL dans R (à l'image de la PROC SQL dans SAS), aussi bien pour des agrégations (par groupe notamment) que pour des fusions. 

--------------


```{r,results = "asis",echo = FALSE}
.question("Effectuer des manipulations complexes sur des données statistiques")
```


a. On souhaite calculer le taux de chômage au niveau national et régional. Le taux de chômage est défini par le ratio du nombre total d'individus au chômage (`acteu %in% "2"`) sur la taille de la population active (`acteu %in% c("1", "2")`).

    ----------

    **Remarque** Le fichier utilisé ici ne comporte que les logements en première ou sixième interrogation : les estimations effectuées dans ce cas pratique n'ont donc aucune raison de coïncider avec les estimations officielles (qui par ailleurs sont CVS-CJO). 

    ----------

    i. Calculez le taux de chômage national, d'abord non-pondéré puis pondéré par la variable `extri1613``r .fun("sum")`. 
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # Taux de chômage non-pondéré
        sum(eec$acteu %in% "2", na.rm = TRUE) / 
          sum(eec$acteu %in% c("1", "2"), na.rm = TRUE)
        # Note : On utilise eec$acteu %in% "2" plutôt que 
        # eec$acteu == "2" car les deux opérateurs ne traitent
        # pas de façon identique les valeurs manquantes quand
        # il y en a.

        # Taux de chômage pondéré
        with(eec, {
          sum((acteu %in% "2") * extri1613, na.rm = TRUE) / 
            sum((acteu %in% c("1", "2")) * extri1613, na.rm = TRUE)
        })
        # Note : la fonction with() permet d'alléger l'écriture 
        # en ne répétant pas le nom de la table (sur la différence
        # avec within(), cf. l'aide)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    ii. Utilisez les fonctions `aggregate()``r .fun("aggregate")`, `tapply()``r .fun("tapply")` et `sapply()``r .fun("sapply")` (avec `split()``r .fun("split")` dans le dernier cas) pour calculer un taux de chômage non-pondéré et par région (variable `reg`). 
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # Les trois fonctions mentionnées en consigne permettent
        # d'appliquer le même traitement à différents groupes
        # d'observations définis selon les modalités d'une variable
        # qualitative (ici la variable de région reg)
        
        # Avec aggregate()
        aggregate(eec$acteu, list(eec$reg), function(x){
          sum(x %in% "2", na.rm = TRUE) /
            sum(x %in% c("1", "2"), na.rm = TRUE)
        })

        # Avec tapply()
        tapply(eec$acteu, eec$reg, function(x){
          sum(x %in% "2", na.rm = TRUE) /
            sum(x %in% c("1", "2"), na.rm = TRUE)
        })
        
        # Avec sapply() et split()
        sapply(split(eec, eec$reg), function(x){
          sum(x$acteu %in% "2", na.rm = TRUE) /
            sum(x$acteu %in% c("1", "2"), na.rm = TRUE)
        })
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```
    
    iii. Utilisez la fonction `sapply()``r .fun("sapply")` avec `split()``r .fun("split")` pour calculer un taux de chômage pondéré et par région.

    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # Pour pondérer le calcul du taux de chômage, il faut
        # pouvoir appliquer la fonction de calcul à deux éléments : 
        # la valeur de la variable acteu et la pondération extri1613.
        
        # Or les fonctions aggregate() et tapply() ne portent 
        # que sur des vecteurs et ne conviennent donc pas.
        # On se limite donc à la méthode avec sapply() et split(). 
        sapply(split(eec, eec$reg), function(x){
          sum((x$acteu %in% "2") * x$extri1613, na.rm = TRUE) / 
            sum((x$acteu %in% c("1", "2")) * x$extri1613, na.rm = TRUE)
        })
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```



b. Pour des raisons de stockage et de performances, on souhaite optimiser le type des variables de l'objet `eec`. En effet, R manipule beaucoup plus efficacement les variables de type numérique que les variables de type caractère. 

    i. Déterminer sous la forme d'un vecteur logique quelles variables de l'objet `eec` sont de type caractère.`r .fun("is.character")``r .fun("sapply")`

        ```{r, results = "asis", echo = FALSE}
        .indic("**Indication** Utilisez la fonction `is.character()` dans une structure `*apply()`.")
        ```
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # Pour tester le fait qu'une variable est de type caractère, 
        # il suffit d'utiliser la fonction is.character()
        is.character(eec$trim)
        
        # Pour appliquer cette fonction à l'ensemble des colonnes
        # de l'objet eec et récupérer un vecteur en sortie, 
        # il suffit d'utiliser la fonction sapply()
        sapply(eec, is.character)
        
        # On stocke ce résultat pour le réutiliser par la suite :
        varChar <- sapply(eec, is.character)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    ii. Créez la table `eec7` dans lequel toutes les variables de type caractère de `eec` à l'exception de ident et noi sont converties en variables de type numérique.`r .fun("lapply")`
    
        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r, error = TRUE}
        # Construction du vecteur logique des variables 
        # à convertir en numérique (varChar privé de ident et noi)
        toNum <- varChar
        toNum[c("ident", "noi")] <- FALSE
        toNum
        
        # Création de l'objet eec7
        eec7 <- eec
        eec7[toNum] <- lapply(eec7[toNum], as.numeric)
        str(eec7)
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```

    iii. Pour chaque variable numérique de `eec7`, testez si la conversion en nombre entier (grâce à la fonction `as.integer()`) est sans perte. Quand c'est le cas, convertissez la variable en nombre entier.`r .fun("as.integer", bold = TRUE)``r .fun("is.numeric")``r .fun("identical")``r .fun("function")``r .fun("object\\_size", bold = TRUE)``r .fun("microbenchmark")`

        ```{r,results = "asis",echo = FALSE}
        .beginsol()
        ```
        ```{r benchmark2, error = TRUE}
        # On procède de façon analogue à précédemment : 
        
        # 1) Identification des variables numériques avec un sapply()
        varNum <- sapply(eec7, is.numeric)
        
        # 2) Pour déterminer si la conversion en entier est sans perte, 
        # on teste l'identité par double-conversion. Par exemple : 
        identical(eec7$acteu, as.numeric(as.integer(eec7$acteu)))
        
        # 3) On définit alors la fonction convertirSiSansPerte() : 
        convertirSiSansPerte <- function(x){
          if(identical(x, as.numeric(as.integer(x)))){
            as.integer(x)
          }else{
            x
          }
        }
        
        # 4) Il ne reste plus qu'à appliquer cette fonction
        # à toutes les variables numériques de eec7 via un lapply()
        eec7[varNum] <- lapply(eec7[varNum], convertirSiSansPerte)
        str(eec7)
        
        # Quelques comparaisons
        
        # - taille des objets avec le package pryr
        # install.packages("pryr")
        library(pryr)
        object_size(eec)
        object_size(eec7)
        
        ```
        ```{r, eval=FALSE}
        # - vitesse d'exécution avec microbenchmark()
        # install.packages("microbenchmark")
        library(microbenchmark)
        microbenchmark(times = 1000
          , eec = sum(eec$acteu == "2", na.rm = TRUE)
          , eec7 = sum(eec7$acteu == 2, na.rm = TRUE)
        )
        ```
        ```{r, echo=FALSE}
        if(!(".bench2.RData" %in% list.files(all.files = TRUE))){
          .bench2 <- microbenchmark(times = 1000
            , eec = sum(eec$acteu == "2", na.rm = TRUE)
            , eec7 = sum(eec7$acteu == 2, na.rm = TRUE)
          )
          save(.bench2, file = ".bench2.RData")
        }
        load(".bench2.RData")
        .bench2
        ```
        ```{r,results = "asis",echo = FALSE}
        .endsol()
        ```


```{r, results = "asis", echo = FALSE}
.partie("Calculer des statistiques descriptives")
```

La plupart des fonctions permettant de calculer des statistiques descriptives ont été présentées tout au long de la formation : `table()`, `summary()`, etc. **Cette partie revient sur l'utilisation de ces fonctions dans une perspective proprement statistique, en élargissant leur utilisation au cas des données pondérées**. 

**L'ensemble des éléments introduits dans cette partie sont mis en pratique sur les données de l'enquête Pisa 2012** (*cf.* dernière sous-partie). 


```{r, results = "asis", echo = FALSE}
.souspartie("Variables qualitatives")
```

La fonction `table()``r .fun("table", bold = TRUE)` calcule les **fréquences** (non-pondérées) des modalités ou des croisements de modalités d'une ou plusieurs variables qualitatives. 

```{r}
# Fréquences des modalités de la variable pub3fp
# Signification des modalités : 
# 1 : Fonction publique d'Etat
# 2 : Fonction publique territoriale
# 3 : Fonction publique hospitalitère
# 4 : Secteur privé
table(eec$pub3fp)

# Utilisation de l'argument useNA pour afficher les valeurs manquantes
table(eec$pub3fp, useNA = "always")

# Croisement avec le sexe
table(eec$pub3fp, eec$sexe, useNA = "always")
```

Pour améliorer l'affichage des résultats de la fonction `table()`, le plus simple est de **transformer les variables caractères utilisées en facteurs**, au préalable ou directement dans la fonction `table()`. 

```{r}
# Transformation de pub3fp en factor
eec$pub3fp <- factor(eec$pub3fp, labels = c(
  "Fonction publique d'Etat"
  , "Fonction publique territoriale"
  , "Fonction publique hospitalière"
  , "Secteur privé"
))

# Impact sur l'affichage de table()
table(eec$pub3fp, eec$sexe, useNA = "always")

# Tranformation à la volée de eec$sexe en factor
table(eec$pub3fp, factor(eec$sexe, labels = c("Homme","Femme")), useNA = "always")
```

\ 

**Les fonctions `addmargins()` et `prop.table()` permettent d'ajouter les marges et de calculer des pourcentages respectivement**`r .fun("addmargins", bold = TRUE)``r .fun("prop.table", bold = TRUE)`. 

```{r}
t <- table(eec$pub3fp, eec$sexe, useNA = "always")

# Ajout de marges avec la fonction addmargins()
addmargins(t)

# Calcul de pourcentages
prop.table(t) # Pourcentages de cellule
prop.table(t, 1) # Pourcentages en ligne
prop.table(t, 2) # Pourcentages en colonne
```

\ 

**La fonction `chisq.test()` mène le test d'indépendance du $\chi^2$**`r .fun("chisq.test", bold = TRUE)`. 
```{r}
# Test du chi2 sur le lien entre eec$pub3fp et eec$sexe
chisq.test(eec$pub3fp, eec$sexe)
```

\ 

----------------

\ 

Au-delà de ces fonctions natives, **le *package* `descr` facilite considérablement l'analyse uni- et bivariée de variables qualitatives**, en particulier quand les données ont à être pondérées (données d'enquête).

```{r}
# Installation du package descr
# install.packages("descr")

# Chargement du package descr
library(descr)
```

La **fonction `freq()`**`r .fun("freq", bold = TRUE)` présente les résultats d'un tri à plat de façon plus complète et plus naturelle et son argument `w` permet de pondérer les calculs. 

```{r, fig.show = "hide"}
# Tri à plat non-pondéré sur la variable eec$pub3fp
freq(eec$pub3fp)
```

```{r, fig.show = "hide"}
# Tri à plat pondéré sur la variable eec$pub3fp
freq(eec$pub3fp, w = eec$extri1613)
```

De même, la **fonction `crosstab()`**`r .fun("crosstab", bold = TRUE)` simplifie l'interprétation d'un tri croisé et l'utilisation de pondérations. 

```{r, fig.show = "hide"}
# Tri croisé non-pondéré des variables eec$pub3fp et eec$sexe
crosstab(eec$pub3fp, eec$sexe)

# Tri croisé pondéré des variables eec$pub3fp et eec$sexe
crosstab(eec$pub3fp, eec$sexe, w = eec$extri1613)

# Ajout des pourcentages en ligne et en colonne
crosstab(eec$pub3fp, eec$sexe, w = eec$extri1613, prop.r = TRUE, prop.c = TRUE)

# Test du chi2
crosstab(
  eec$pub3fp, eec$sexe, w = eec$extri1613 / mean(eec$extri1613)
  , prop.chisq = TRUE,  chisq = TRUE
)
```


```{r, results = "asis", echo = FALSE}
.souspartie("Variables quantitatives")
```

Contrairement à d'autres logiciels statistiques (SAS tout particulièrement), **R ne possède pas une procédure permettant de calculer automatiquement l'ensemble des statistiques descriptives standards** dans le cas d'une variable de nature quantitative, mais un **ensemble de fonctions élémentaires** (*cf.* tableau).

**Code R** | **Résultat**
----------|---------
`sum(x)``r .fun("sum", bold = TRUE)` | Somme de `x`
`mean(x)``r .fun("mean", bold = TRUE)`  | Moyenne de `x`
`var(x)``r .fun("var", bold = TRUE)`  | Variance empirique de `x`
`sd(x)``r .fun("sd", bold = TRUE)`  | Écart-type empirique de `x`
`quantile(x)``r .fun("quantile", bold = TRUE)` | Quantiles de `x`
`summary(x)``r .fun("summary", bold = TRUE)` | Moyenne et quantiles de `x`
`max(x)``r .fun("max", bold = TRUE)`  | Valeur maximum de `x`
`min(x)``r .fun("min", bold = TRUE)`  | Valeur minimum de `x`
`range(x)``r .fun("range", bold = TRUE)`  | Valeur minimale et valeur maximale de `x`
`cor.test(x, y)``r .fun("cor.test", bold = TRUE)` | Corrélation entre `x` et `y`

**En présence de valeurs manquantes (`NA`), la plupart de ces fonctions renvoient la valeur `NA` : l'argument `na.rm = TRUE` permet de modifier ce comportement.**

```{r}
# Statistiques descriptives standards sur le salaire dans l'EEC

mean(eec$salred) 
# Il y a manifestement des valeurs manquantes
sum(is.na(eec$salred))
# Les valeurs manquantes correspondent à 19 794 observations 
# sur 34 913, ce qui est logique : ni les inactifs ni les non-
# salariés ne touchent de salaire. 

mean(eec$salred, na.rm = TRUE)
sd(eec$salred, na.rm = TRUE)
quantile(eec$salred, na.rm = TRUE)
quantile(eec$salred, na.rm = TRUE, probs = c(0.01, 0.05, 0.95, 0.99))
range(eec$salred, na.rm = TRUE)

# Coefficients de corrélation
cor.test(eec$salred, as.numeric(eec$age), method = "pearson")
cor.test(eec$salred, as.numeric(eec$age), method = "spearman")
cor.test(eec$salred, as.numeric(eec$age), method = "kendall")
```

Comme dans le cas des variables qualitatives, **par défaut R ne prend pas en charge le calcul de statistiques descriptives pondérées**. C'est ce que fait en revanche le ***package* `Hmisc`**, avec la série des fonctions `wtd` : `wtd.mean()``r .fun("wtd.mean", bold = TRUE)`, `wtd.var()``r .fun("wtd.var", bold = TRUE)`, `wtd.quantile()``r .fun("wtd.quantile", bold = TRUE)` notamment, qui comportent un argument `weights`. 

```{r}
# Installation du package Hmisc
# install.packages("Hmisc")

# Chargement du package Hmisc
library(Hmisc)

# Statistiques pondérées avec Hmisc
wtd.mean(eec$salred, weights = eec$extri1613)
sqrt(wtd.var(eec$salred, weights = eec$extri1613))
wtd.quantile(eec$salred, weights = eec$extri1613, probs = seq(0, 1, 0.05))
# Note : les fonctions wtd. du package Hmisc disposent 
# également d'un paramètres na.rm, mais sa valeur est TRUE
# par défaut.
```


```{r, results = "asis", echo = FALSE}
.souspartie("Graphiques")
```

La production de graphiques est relativement simple dans R : dans la plupart des cas, **c'est la fonction `plot()` qu'il convient d'utiliser, qui adapte automatiquement le graphique aux caractéristiques de l'objet représenté**. De nombreuses **options graphiques**`r .fun("plot", bold = TRUE)` (taper `? plot` pour en afficher quelques unes) permettent de personnaliser assez finement l'affichage. 

\ 

Pour représenter un **nuage de points**, il suffit par exemple d'appliquer `plot()` aux deux variables à représenter.

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# On se restreint à une sous-base pour ne pas avoir un
# nuage de points trop dense
eec8 <- eec[which(!is.na(eec$salred))[1:100], ]
eec8$age <- as.numeric(eec8$age)

# Représentation du salaire en fonction de l'âge
plot(eec8$age, eec8$salred)
```

Plusieurs options de base contrôlent l'**affichage des titres et des axes** :

- `main` : titre principal du graphique ;
- `xlab`, `ylab` : titres des axes ;
- `xlim`, `ylim` : vecteurs de longueur 2 indiquant les limites des axes des abscisses et des ordonnées respectivement. 

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# Personnalisation du graphique précédent (1)
plot(
  eec8$age, eec8$salred
  , main = "Âge et salaire dans l'EEC 2012 T4"
  , xlab = "Âge", ylab = "Salaire en euros"
  , xlim= c(15, 75)
)
```

Les options `pch` et `col` permettent de **modifier la forme et la couleur des points représentés**. 

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# Personnalisation du graphique précédent (2)
plot(
  eec8$age, eec8$salred
  , main = "Âge et salaire dans l'EEC 2012 T4"
  , xlab = "Âge", ylab = "Salaire en euros"
  , xlim= c(15, 75)
  , pch = 0, col = 2
)
```

Utilisées avec des vecteurs et la fonction `legend()``r .fun("legend", bold = TRUE)`, `pch` et `col` permettent de **représenter le croisement de plusieurs variables**. 

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# Utilisation de pch pour distinguer hommes et femmes 
# sur le graphique
plot(
  eec8$age, eec8$salred
  , main = "Âge et salaire dans l'EEC 2012 T4"
  , xlab = "Âge", ylab = "Salaire en euros"
  , xlim= c(15, 75)
  , pch = as.numeric(eec8$sexe == "2") 
)

# Ajout d'une légende
legend("topright", legend=c("Hommes","Femmes"), pch=c(0, 1))

# Sauvegarde du graphique pour la suite
g1 <- recordPlot()
```

Les fonctions `abline()``r .fun("abline", bold = TRUE)` et `curve()``r .fun("curve", bold = TRUE)` **ajoutent respectivement des lignes et des courbes à un graphique existant**. 

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# Modèle de régression linéaire : salaire = age + sexe
# (cf. dernière partie)
eec8$femme <- eec8$sexe == "2"
m1 <- lm(salred ~ age + femme, data = eec8)

# Représentation des droites de régression correspondant
# aux hommes et aux femmes respectivement
g1
abline(a = coef(m1)[1], b = coef(m1)[2])
abline(a = coef(m1)[1] + coef(m1)[3], b = coef(m1)[2], lty = 2)
```

```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
# Modèle de régression linéaire : salaire = age + age^2 + sexe
# (cf. sous-partie suivante)
eec8$age2 <- eec8$age^2
m2 <- lm(salred ~ age + age2 + femme, data = eec8)

# Représentation des courbes de régression correspondant
# aux hommes et aux femmes respectivement
g1
curve(coef(m2)[1] + coef(m2)[2]*x + coef(m2)[3]*x^2, add = TRUE)
curve(coef(m2)[1] + coef(m2)[4] + coef(m2)[2]*x + coef(m2)[3]*x^2, lty=2, add = TRUE)
```


\ 

La fonction `plot()``r .fun("plot")` permet également de représenter la **fonction de répartition et la densité empirique d'une distribution**, par le biais des fonctions `ecdf()``r .fun("ecdf", bold = TRUE)` et `density()``r .fun("density", bold = TRUE)`. 

```{r, fig.asp=3/4, out.width="12cm", fig.align="center"}
# Fonction de répartition empirique du salaire
plot(
  ecdf(eec$salred)
  , main = "Fonction de répartition empirique du salaire"
)

# Densité empirique du salaire
plot(
  density(eec$salred, na.rm = TRUE)
  , main = "Densité empirique du salaire"
)
```

\ 

Au-delà de la fonction `plot()`, de nombreuses fonctions permettent d'effectuer des représentations spécifiques dans R : 

- `hist()``r .fun("hist", bold = TRUE)` produit l'histogramme d'une distribution ;

    ```{r, fig.show = "hold", fig.asp=3/4, out.width="12cm", fig.align="center"}
    # Histogramme du salaire dans l'EEC
    hist(eec$salred, xlim = c(0, 4000), breaks = seq(0, 100000, 250))
    ```

- `barplot()``r .fun("barplot", bold = TRUE)` et `pie()``r .fun("pie", bold = TRUE)` produisent respectivement le diagramme en bâtons et le diagramme circulaire représentant la fréquence d'une variable qualitative. 

    ```{r, fig.asp=3/4, out.width="12cm", fig.align="center"}
    # Distribution de la position du marché du travail
    # en milliers
    pos <- by(eec$extri1613, eec$acteu, sum) / 1000
    
    # Diagramme en bâtons de la position sur le marché du travail
    barplot(
      pos
      , names.arg = c("Actifs occupés", "Chômeurs", "Inactifs")
      , main = "Position sur le marché du travail au 2012 T4 \n (en milliers)"
    )

    # Diagramme circulaire de la position sur le marché du travail
    pie(
      pos
      , labels = paste0(c("Actifs occupés", "Chômeurs", "Inactifs"), " (", round(pos),")")
      , main = "Position sur le marché du travail au 2012 T4 \n (en milliers)"
    )
    ```


```{r, results = "asis", echo = FALSE}
.souspartie("Application à l'enquête Pisa 2012")
```

L'enquête Pisa (\textit{Program for International Student Assessment}) est une enquête réalisée **tous les trois ans** par l'Organisation de coopération et de développement économique (OCDE) dans une soixantaine de pays auprès des **élèves de 15 ans** (quelle que soit leur classe au moment de l'enquête). 

Elle vise à mesurer les **acquis des élèves de 15 ans dans trois disciplines** : mathématiques, compréhension de l'écrit (ou [*littératie*](https://fr.wikipedia.org/wiki/Litt%C3%A9ratie)) et sciences. En plus des scores aux **tests standardisés** de mathématiques, compréhension de l'écrit et sciences, cette enquête comporte de très nombreuses informations sur l'origine sociale des élèves, leurs conditions d'enseignement ainsi que leur rapport aux enseignants et à l'école. 

**Organisation des fichiers** Les fichiers de l'enquête Pisa 2012 et leur documentation sont librement téléchargeables sur le [site de l'OCDE](http://www.oecd.org/pisa/pisaproducts/pisa2012database-downloadabledata.htm). Seuls **deux des nombreux fichiers de données** qui constituent l'enquête seront utilisés : 

- le **fichier élève** `pisa_stu.sas7bdat`;
- le **fichier établissement** `pisa_sch.sas7bdat`. 

Ces deux fichiers ont été **restreints à la France** et à un **ensemble réduit de variables**: 

**Fichier élève (`pisa_stu.sas7bdat`)**

| **Variable**               | **Description**                             |
|:---------------------------|:----------------------------------------|
|cnt| Pays|
|stidstd| Identifiant de l'élève|
|schoolid| Identifiant de l'établissement|
|w_fstuwt| Poids de sondage final de l'élève|
|st01q01| Classe en nombre d'années depuis l'entrée en primaire: la 10$^{ème}$ classe correspond à la seconde en France.|
|st04q01 | Sexe : (1) Femme (2) Homme |
|st05q01| A suivi une scolarité pré-primaire (1) Non (2) Oui, un an ou moins (3) Oui, plus d'un an|
|st07q01\ st07q02\ st07q03| A redoublé à un moment de sa scolarité : (1) Non (2-3) Oui, une ou plusieurs fois|
|st08q01| Est arrivé en retard au cours des deux semaines précédant l'enquête  | (1) Non (2) Une ou deux fois (3) Trois ou quatre fois (4) Cinq fois ou plus |
|st09q01| A séché les cours au cours des deux semaines précédant l'enquête | (1) Non (2) Une ou deux fois (3) Trois ou quatre fois (4) Cinq fois ou plus |
|anxmat| Score synthétique d'anxiété en mathématiques|
|disclima| Score synthétique de climat de discipline dans la classe|
|escs| Indicateur synthétique de statut économique, social et culturel |
|immig | Immigration : (1) Né en France (2) Immigré de deuxième génération (3) Immigré de première génération|
|hisced | Niveau d'étude le plus élevé des parents ([nomenclature CITE](http://www.uis.unesco.org/Education/Documents/isced-2011-fr.pdf)) |
|pv1math | Score synthétique à l'évaluation de mathématiques|
|pv1read | Score synthétique à l'évaluation de compréhension de l'écrit|
|pv1scie | Score synthétique à l'évaluation de sciences|

**Fichier établissement (`pisa_sch.sas7bdat`)**

| **Variable**               | **Description**                             |
|:---------------------------|:----------------------------------------|
|cnt| Pays|
|schoolid| Identifiant de l'établissement|
|senwgt_scq| Poids de sondage (la somme vaut 1\ 000 dans chaque pays)|
|sc01q01|Statut public ou privé (1) public (2) privé|
|sc03q01|Taille de la commune de l'établissement : (1) *Village* (2) *Small town* (3) *Town* (4) *City* (5) *Large city*|
|sc05q01| Taille de la classe en cours de français : (01) 15 ou moins (02) 16-20 (03) 21-25 ... (08) 46-50 (09) Plus de 50 élèves|

```{r, results = "asis", echo = FALSE}
.question("Application à l'enquête Pisa 2012 : Importation et mise en forme des données")
```

a. Utilisez la fonction `read_sas()``r .fun("read\\_sas")` du *package* `haven` (*cf.* `r .ref("module 1", "module1.html")`) pour importer les deux fichiers dans les objets `stu` et `sch` respectivement. Afin de faciliter les exploitations futures, passez leurs noms de variables en minuscules`r .fun("names")`. 

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r}
    # Import des fichiers avec la fonction read_sas()
    # install.packages("haven")
    library(haven)
    stu <- read_sas("pisa_stu.sas7bdat")
    sch <- read_sas("pisa_sch.sas7bdat")
    
    # Passage des noms en minuscules
    names(stu) <- tolower(names(stu))
    names(sch) <- tolower(names(sch))
    
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

b. On souhaite pouvoir utiliser les informations au niveau de l'établissement dans des exploitations au niveau des élèves. Pour ce faire, il convient de fusionner les tables `stu` et `sch` sur la base de la variable `schoolid`.

    i. Utilisez les fonctions `unique()``r .fun("unique")`, `intersect()``r .fun("intersect")` et `setdiff()``r .fun("setdiff")` pour vérifier que l'identifiant `schoolid` prend bien les mêmes valeurs dans les deux tables.

        ```{r, results = "asis", echo = FALSE}
        .beginsol()
        ```
        ```{r}
        length(intersect(stu$schoolid, sch$schoolid))
        length(unique(stu$schoolid))
        length(unique(sch$schoolid))
        
        # Cela fonctionne aussi plus finement avec setdiff()
        setdiff(stu$schoolid, sch$schoolid)
        # Aucune valeur de stu$schoolid n'est pas dans sch$schoolid
        setdiff(sch$schoolid, stu$schoolid)
        # Aucune valeur de sch$schoolid n'est pas dans stu$schoolid
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```

    ii. Vérifiez que la variable `schoolid` est un identifiant pour la table `sch`, à savoir : (1) qu'elle est renseignée pour chaque ligne (2) qu'elle prend une valeur distincte pour chaque ligne. 

        ```{r, results = "asis", echo = FALSE}
       .beginsol()
        ```
        ```{r}
        # Pour vérifier que schoolid identifie sch il suffit
        # de comparer le nombre de valeurs distinctes au
        # nombre de lignes
        length(unique(sch$schoolid))
        nrow(sch)
        # Tout va bien !    
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```
 
    iii. Utilisez la fonction `merge()``r .fun("merge")` pour fusionner `stu` et `sch` par `schoolid` et créez la table `stu2`. Vérifiez que ses propriétés sont cohérentes avec le résultat des questions précédentes : même nombre de lignes que `stu`, nombre de colonnes égal à celui de `stu` et de `sch` moins 1.

        ```{r, results = "asis", echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Fusion des deux tables
        stu2 <- merge(stu, sch, by = "schoolid")
    
        # Vérifications 
        nrow(stu2) == nrow(stu)
        ncol(stu2) == ncol(stu) + ncol(sch) - 1
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```
        
c. Recodage de variables

    i. Recodez la variable de sexe en facteur `r .fun("factor")` dont les libellés sont `"Femme"` et `"Homme"` pour faciliter la lecture des tableaux et graphiques.


        ```{r, results = "asis", echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Création de la variable sexe recodée
        stu2$sexe <- factor(stu2$st04q01, labels = c("Femme", "Homme"))
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```
    
    ii. Un élève a redoublé à un moment dans sa scolarité dès lors qu'une des variables `st07q01`, `st07q02` ou `st07q03` vaut 2 ou 3. Créez la variable indicatrice `redoublant` valant `TRUE` si un élève a redoublé au cours de sa scolarité.

        ```{r, results = "asis", echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # Création de la variable redoublant
        stu2$redoublant <- ( 
          stu2$st07q01 %in% c(2, 3) | 
            stu2$st07q02 %in% c(2, 3) | 
            stu2$st07q03 %in% c(2, 3)
        )
        table(stu2$redoublant)
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```

    iii. Quelle est la nature de l'indicateur synthétique de statut économique, social et culturel ? Recodez-le sous la forme d'une variable qualitative à 5 modalités (en utilisant les fonctions `cut()``r .fun("cut", bold = TRUE)` et `quantile()``r .fun("quantile")`). 

        ```{r, results = "asis", echo = FALSE}
        .beginsol()
        ```
        ```{r}
        # La variable escs est de nature quantitative, ce qui n'est pas très naturel
        summary(stu2$escs)
        
        # On la recode en une variable qualitative selon ses quintiles
        # pour facilier les interprétations
        stu2$escsq <-  cut(
          stu2$escs
          , quantile(stu2$escs, probs = c(0, 0.20, 0.40, 0.60, 0.80, 1), na.rm = TRUE)
        )
        table(stu2$escsq)
        ```
        ```{r, results = "asis", echo = FALSE}
        .endsol()
        ```


```{r, results = "asis", echo = FALSE}
.question("Application à l'enquête Pisa 2012 : Statistiques descriptives")
```

a. En utilisant le *package* `descr`, effectuez le tri croisé entre sexe des élèves et redoublement et interprétez-le.`r .fun("crosstab")` 

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```

    ```{r, fig.keep = "none"}
    # Installation du package descr
    # install.packages("descr")
    
    # Chargement du package descr
    library(descr)
    
    # Tri croisé pondéré
    crosstab(
      stu2$sexe, stu2$redoublant, weight = stu2$poids
      , prop.r = TRUE, chisq = TRUE, prop.c = TRUE
    )
    ```
    
    Dans l'ensemble de la population, 27,2\ % des élèves de 15 ans ont redoublé à un moment ou à un autre de leur scolarité. Ils sont 30,2\ % parmi les hommes et 24,5\ % parmi les femmes : autrement dit, les élèves ayant deroublé à un moment ou à un autre de leur scolarité sont surreprésentés parmi les hommes. 
    
    Le test d'indépendance du $\chi^2$ permet de confirmer cette analyse : sa p-valeur est inférieure à 0,01 aussi il est possible de rejeter l'hypothèse nulle d'indépendance entre les variables de sexe et de reoublement au seuil de 1\ %. 
    
    ```{r, results = "asis", echo = FALSE}
.endsol()
    ```
    

b. Calculez le coefficient de corrélation linéaire de Pearson entre notes en mathématiques et en sciences et menez le test de nullité de ce coefficient (avec la fonction `cor.test()`)`r .fun("cor.test")`.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```

    ```{r, fig.keep = "none"}
    cor.test(stu2$pv1math, stu2$pv1scie)
    ```
    
    Le coefficient de corrélation entre note en mathématiques et note en sciences est positif et extrêmement élevé (`r .f(cor(stu2$pv1math, stu2$pv1scie), 4)`). La p-valeur du test de nullité de ce coefficient est inférieure à 0,01 aussi il est possible de rejeter au seuil de 1\ % l'hypothèse que ces deux scores ne soient pas corrélés.
    
    ```{r, results = "asis", echo = FALSE}
.endsol()
    ```

c. Calculez le score moyen en mathématiques selon les quintiles de statut économique, social et culturel (*cf.* le recodage du cas pratique précédent).`r .fun("tapply")`
    
    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```

    ```{r, fig.keep = "none"}
    tapply(stu2$pv1math, stu2$escsq, mean)
    ```
    La moyenne du score en mathématiques est d'autant plus élevée que le statut économique, social et culturel est favorisé.
    
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```


```{r, results = "asis", echo = FALSE}
.question("Application à l'enquête Pisa 2012 : Graphiques")
```

a. Construisez un diagramme en bâton pour illustrer la relation entre statut économique, social et culturel (en quintiles) et redoublement. Utilisez les options de mise en forme pour améliorer sa présentation (ajouter un titre avec `main()`, modifiez les titres des axes avec `xlab()` et `ylab()`, etc.)`r .fun("barplot")`.

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, fig.asp=3/4, out.width="12cm", fig.align="center"}
    barplot(
      table(stu2$redoublant, stu2$escsq)
      , main = "Statut économique, social et culturel\net redoublement"
      , xlab = "Statut économique, social et cuturel"
      , ylab = "Répartition des redoublants"
      , legend.text = c("Non-redoublant", "Redoublant")
      , args.legend = list(x = "topleft", bg = "white")
    )
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

b. Utilisez la fonction `plot()` pour représenter le nuage de points de la relation entre le score en mathématiques et le score en sciences.`r .fun("plot")`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, fig.asp=3/4, out.width="12cm", fig.align="center"}
    # Score en mathématiques et en sciences
    par(pty="s")
    plot(
      stu2$pv1math, stu2$pv1scie
      , xlab = "Score en mathématiques"
      , ylab = "Score en sciences"
    )
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

c. Construisez la "boîte à moustaches" représentant la relation entre stat au moinst économique, social et culturel (en quintiles) et score en mathématiques à l'aide de la fonction `boxplot()`.`r .fun("boxplot", bold = TRUE)`

    ```{r, results = "asis", echo = FALSE}
    .beginsol()
    ```
    ```{r, fig.asp=3/4, out.width="12cm", fig.align="center"}
    boxplot(
      stu2$pv1math ~ stu2$escsq
      , main = "Statut économique, social et culturel\net score en sciences"
      , xlab = "Statut économique, social et cuturel"
      , ylab = "Score en mathématiques"
    )
    ```
    ```{r, results = "asis", echo = FALSE}
    .endsol()
    ```

d. Utilisez les fonctionnalités de RStudio (menus déroulants de la fenêtre de graphiques) pour sauvegarder ces graphiques dans la qualité et le format souhaités.





```{r, results = "asis", echo = FALSE}
.partie("Quelques liens pour aller plus loin")
```

```{r,results = "asis",echo = FALSE}
.souspartie("Formation R perfectionnement")
```

Le support de la formation R perfectionnement est en ligne à l'adresse : [t.slmc.fr/perf](http://teaching.slmc.fr/perf). Elle aborde trois sujets : 

1. Outils et méthodes pour se perfectionner avec R ;

2. Traitements avancés sur des données dans R : retour sur les fonctions `*apply()` et assimilées, optimisation en base R, *packages* `dplyr` et `data.table`, parallélisation et utilisation de langages de bas niveau dans R.

3. Graphiques et *reporting* avec R : *package* `ggplot2`, production automatique de documents avec Rmarkdown. 

Un cycle de formations perfectionnement est également proposé par la Division Formation : certaines portent sensiblement sur les mêmes sujets, mais pas toutes (notamment une consacrée à [R Shiny](https://shiny.rstudio.com/)). 

```{r,results = "asis",echo = FALSE}
.souspartie("Utiliser des techniques d'analyse de données multidimensionnelles")
```

Le package `FactoMineR` (attention à la casse !) rend extrêmement simple la mise en oeuvre sous R de **techniques d'analyse de données multidimensionnelles** : analyse en composante principale (ACP), analyse des correspondances multiples (ACM) ou encore classification ascendante hiérarchique (CAH). 

Ce [document d'introduction](https://cran.r-project.org/web/packages/FactoMineR/vignettes/FactoMineR.pdf) ("vignette" dans la terminologie de R) présente ces méthodes et leur mise en oeuvre avec `FactoMineR`. 

```{r,results = "asis",echo = FALSE}
.souspartie("Estimer des modèles de régression")
```

Les fonctions natives de R `lm()` et `glm()` permettent respectivement d'estimer des **modèles linéaires et linéaires généralisés** (dont les modèles logistiques). 

[Cette page](http://teaching.slmc.fr/mqs2) (destinée à un public de non-statisticiens) introduit les méthodes de régression et propose de nombreux exemples d'estimation de modèles dans R. 

<!--chapter:end:03-mise-en-pratique.Rmd-->

